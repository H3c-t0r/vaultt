// Code generated by protoc-gen-go. DO NOT EDIT.
// source: logical/plugin/pb/backend.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Header struct {
	Header               []string `sentinel:"" protobuf:"bytes,1,rep,name=header" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{1}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Header.Unmarshal(m, b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Header.Marshal(b, m, deterministic)
}
func (dst *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(dst, src)
}
func (m *Header) XXX_Size() int {
	return xxx_messageInfo_Header.Size(m)
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetHeader() []string {
	if m != nil {
		return m.Header
	}
	return nil
}

type ProtoError struct {
	// Error type can be one of:
	// ErrTypeUnknown uint32 = iota
	// ErrTypeUserError
	// ErrTypeInternalError
	// ErrTypeCodedError
	// ErrTypeStatusBadRequest
	// ErrTypeUnsupportedOperation
	// ErrTypeUnsupportedPath
	// ErrTypeInvalidRequest
	// ErrTypePermissionDenied
	// ErrTypeMultiAuthzPending
	ErrType              uint32   `sentinel:"" protobuf:"varint,1,opt,name=err_type,json=errType" json:"err_type,omitempty"`
	ErrMsg               string   `sentinel:"" protobuf:"bytes,2,opt,name=err_msg,json=errMsg" json:"err_msg,omitempty"`
	ErrCode              int64    `sentinel:"" protobuf:"varint,3,opt,name=err_code,json=errCode" json:"err_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtoError) Reset()         { *m = ProtoError{} }
func (m *ProtoError) String() string { return proto.CompactTextString(m) }
func (*ProtoError) ProtoMessage()    {}
func (*ProtoError) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{2}
}
func (m *ProtoError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtoError.Unmarshal(m, b)
}
func (m *ProtoError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtoError.Marshal(b, m, deterministic)
}
func (dst *ProtoError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoError.Merge(dst, src)
}
func (m *ProtoError) XXX_Size() int {
	return xxx_messageInfo_ProtoError.Size(m)
}
func (m *ProtoError) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoError.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoError proto.InternalMessageInfo

func (m *ProtoError) GetErrType() uint32 {
	if m != nil {
		return m.ErrType
	}
	return 0
}

func (m *ProtoError) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *ProtoError) GetErrCode() int64 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

// Paths is the structure of special paths that is used for SpecialPaths.
type Paths struct {
	// Root are the paths that require a root token to access
	Root []string `sentinel:"" protobuf:"bytes,1,rep,name=root" json:"root,omitempty"`
	// Unauthenticated are the paths that can be accessed without any auth.
	Unauthenticated []string `sentinel:"" protobuf:"bytes,2,rep,name=unauthenticated" json:"unauthenticated,omitempty"`
	// LocalStorage are paths (prefixes) that are local to this instance; this
	// indicates that these paths should not be replicated
	LocalStorage []string `sentinel:"" protobuf:"bytes,3,rep,name=local_storage,json=localStorage" json:"local_storage,omitempty"`
	// SealWrapStorage are storage paths that, when using a capable seal,
	// should be seal wrapped with extra encryption. It is exact matching
	// unless it ends with '/' in which case it will be treated as a prefix.
	SealWrapStorage      []string `sentinel:"" protobuf:"bytes,4,rep,name=seal_wrap_storage,json=sealWrapStorage" json:"seal_wrap_storage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Paths) Reset()         { *m = Paths{} }
func (m *Paths) String() string { return proto.CompactTextString(m) }
func (*Paths) ProtoMessage()    {}
func (*Paths) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{3}
}
func (m *Paths) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Paths.Unmarshal(m, b)
}
func (m *Paths) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Paths.Marshal(b, m, deterministic)
}
func (dst *Paths) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Paths.Merge(dst, src)
}
func (m *Paths) XXX_Size() int {
	return xxx_messageInfo_Paths.Size(m)
}
func (m *Paths) XXX_DiscardUnknown() {
	xxx_messageInfo_Paths.DiscardUnknown(m)
}

var xxx_messageInfo_Paths proto.InternalMessageInfo

func (m *Paths) GetRoot() []string {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Paths) GetUnauthenticated() []string {
	if m != nil {
		return m.Unauthenticated
	}
	return nil
}

func (m *Paths) GetLocalStorage() []string {
	if m != nil {
		return m.LocalStorage
	}
	return nil
}

func (m *Paths) GetSealWrapStorage() []string {
	if m != nil {
		return m.SealWrapStorage
	}
	return nil
}

type Request struct {
	// ID is the uuid associated with each request
	ID string `sentinel:"" protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// If set, the name given to the replication secondary where this request
	// originated
	ReplicationCluster string `sentinel:"" protobuf:"bytes,2,opt,name=ReplicationCluster" json:"ReplicationCluster,omitempty"`
	// Operation is the requested operation type
	Operation string `sentinel:"" protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
	// Path is the part of the request path not consumed by the
	// routing. As an example, if the original request path is "prod/aws/foo"
	// and the AWS logical backend is mounted at "prod/aws/", then the
	// final path is "foo" since the mount prefix is trimmed.
	Path string `sentinel:"" protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// Request data is a JSON object that must have keys with string type.
	Data string `sentinel:"" protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
	// Secret will be non-nil only for Revoke and Renew operations
	// to represent the secret that was returned prior.
	Secret *Secret `sentinel:"" protobuf:"bytes,6,opt,name=secret" json:"secret,omitempty"`
	// Auth will be non-nil only for Renew operations
	// to represent the auth that was returned prior.
	Auth *Auth `sentinel:"" protobuf:"bytes,7,opt,name=auth" json:"auth,omitempty"`
	// Headers will contain the http headers from the request. This value will
	// be used in the audit broker to ensure we are auditing only the allowed
	// headers.
	Headers map[string]*Header `sentinel:"" protobuf:"bytes,8,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ClientToken is provided to the core so that the identity
	// can be verified and ACLs applied. This value is passed
	// through to the logical backends but after being salted and
	// hashed.
	ClientToken string `sentinel:"" protobuf:"bytes,9,opt,name=client_token,json=clientToken" json:"client_token,omitempty"`
	// ClientTokenAccessor is provided to the core so that the it can get
	// logged as part of request audit logging.
	ClientTokenAccessor string `sentinel:"" protobuf:"bytes,10,opt,name=client_token_accessor,json=clientTokenAccessor" json:"client_token_accessor,omitempty"`
	// DisplayName is provided to the logical backend to help associate
	// dynamic secrets with the source entity. This is not a sensitive
	// name, but is useful for operators.
	DisplayName string `sentinel:"" protobuf:"bytes,11,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// MountPoint is provided so that a logical backend can generate
	// paths relative to itself. The `Path` is effectively the client
	// request path with the MountPoint trimmed off.
	MountPoint string `sentinel:"" protobuf:"bytes,12,opt,name=mount_point,json=mountPoint" json:"mount_point,omitempty"`
	// MountType is provided so that a logical backend can make decisions
	// based on the specific mount type (e.g., if a mount type has different
	// aliases, generating different defaults depending on the alias)
	MountType string `sentinel:"" protobuf:"bytes,13,opt,name=mount_type,json=mountType" json:"mount_type,omitempty"`
	// MountAccessor is provided so that identities returned by the authentication
	// backends can be tied to the mount it belongs to.
	MountAccessor string `sentinel:"" protobuf:"bytes,14,opt,name=mount_accessor,json=mountAccessor" json:"mount_accessor,omitempty"`
	// WrapInfo contains requested response wrapping parameters
	WrapInfo *RequestWrapInfo `sentinel:"" protobuf:"bytes,15,opt,name=wrap_info,json=wrapInfo" json:"wrap_info,omitempty"`
	// ClientTokenRemainingUses represents the allowed number of uses left on the
	// token supplied
	ClientTokenRemainingUses int64 `sentinel:"" protobuf:"varint,16,opt,name=client_token_remaining_uses,json=clientTokenRemainingUses" json:"client_token_remaining_uses,omitempty"`
	// EntityID is the identity of the caller extracted out of the token used
	// to make this request
	EntityID string `sentinel:"" protobuf:"bytes,17,opt,name=entity_id,json=entityId" json:"entity_id,omitempty"`
	// PolicyOverride indicates that the requestor wishes to override
	// soft-mandatory Sentinel policies
	PolicyOverride bool `sentinel:"" protobuf:"varint,18,opt,name=policy_override,json=policyOverride" json:"policy_override,omitempty"`
	// Whether the request is unauthenticated, as in, had no client token
	// attached. Useful in some situations where the client token is not made
	// accessible.
	Unauthenticated bool `sentinel:"" protobuf:"varint,19,opt,name=unauthenticated" json:"unauthenticated,omitempty"`
	// Connection will be non-nil only for credential providers to
	// inspect the connection information and potentially use it for
	// authentication/protection.
	Connection           *Connection `sentinel:"" protobuf:"bytes,20,opt,name=connection" json:"connection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{4}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (dst *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(dst, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Request) GetReplicationCluster() string {
	if m != nil {
		return m.ReplicationCluster
	}
	return ""
}

func (m *Request) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

func (m *Request) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Request) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Request) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *Request) GetAuth() *Auth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *Request) GetHeaders() map[string]*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Request) GetClientToken() string {
	if m != nil {
		return m.ClientToken
	}
	return ""
}

func (m *Request) GetClientTokenAccessor() string {
	if m != nil {
		return m.ClientTokenAccessor
	}
	return ""
}

func (m *Request) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Request) GetMountPoint() string {
	if m != nil {
		return m.MountPoint
	}
	return ""
}

func (m *Request) GetMountType() string {
	if m != nil {
		return m.MountType
	}
	return ""
}

func (m *Request) GetMountAccessor() string {
	if m != nil {
		return m.MountAccessor
	}
	return ""
}

func (m *Request) GetWrapInfo() *RequestWrapInfo {
	if m != nil {
		return m.WrapInfo
	}
	return nil
}

func (m *Request) GetClientTokenRemainingUses() int64 {
	if m != nil {
		return m.ClientTokenRemainingUses
	}
	return 0
}

func (m *Request) GetEntityID() string {
	if m != nil {
		return m.EntityID
	}
	return ""
}

func (m *Request) GetPolicyOverride() bool {
	if m != nil {
		return m.PolicyOverride
	}
	return false
}

func (m *Request) GetUnauthenticated() bool {
	if m != nil {
		return m.Unauthenticated
	}
	return false
}

func (m *Request) GetConnection() *Connection {
	if m != nil {
		return m.Connection
	}
	return nil
}

type Entity struct {
	// ID is the unique identifier for the entity
	ID string `sentinel:"" protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name is the human-friendly unique identifier for the entity
	Name string `sentinel:"" protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Aliases contains thhe alias mappings for the given entity
	Aliases              []*Alias `sentinel:"" protobuf:"bytes,3,rep,name=aliases" json:"aliases,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Entity) Reset()         { *m = Entity{} }
func (m *Entity) String() string { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()    {}
func (*Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{5}
}
func (m *Entity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Entity.Unmarshal(m, b)
}
func (m *Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Entity.Marshal(b, m, deterministic)
}
func (dst *Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity.Merge(dst, src)
}
func (m *Entity) XXX_Size() int {
	return xxx_messageInfo_Entity.Size(m)
}
func (m *Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Entity proto.InternalMessageInfo

func (m *Entity) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Entity) GetAliases() []*Alias {
	if m != nil {
		return m.Aliases
	}
	return nil
}

type Alias struct {
	// MountType is the backend mount's type to which this identity belongs
	MountType string `sentinel:"" protobuf:"bytes,1,opt,name=mount_type,json=mountType" json:"mount_type,omitempty"`
	// MountAccessor is the identifier of the mount entry to which this
	// identity belongs
	MountAccessor string `sentinel:"" protobuf:"bytes,2,opt,name=mount_accessor,json=mountAccessor" json:"mount_accessor,omitempty"`
	// Name is the identifier of this identity in its authentication source
	Name                 string   `sentinel:"" protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Alias) Reset()         { *m = Alias{} }
func (m *Alias) String() string { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()    {}
func (*Alias) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{6}
}
func (m *Alias) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Alias.Unmarshal(m, b)
}
func (m *Alias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Alias.Marshal(b, m, deterministic)
}
func (dst *Alias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alias.Merge(dst, src)
}
func (m *Alias) XXX_Size() int {
	return xxx_messageInfo_Alias.Size(m)
}
func (m *Alias) XXX_DiscardUnknown() {
	xxx_messageInfo_Alias.DiscardUnknown(m)
}

var xxx_messageInfo_Alias proto.InternalMessageInfo

func (m *Alias) GetMountType() string {
	if m != nil {
		return m.MountType
	}
	return ""
}

func (m *Alias) GetMountAccessor() string {
	if m != nil {
		return m.MountAccessor
	}
	return ""
}

func (m *Alias) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Auth struct {
	LeaseOptions *LeaseOptions `sentinel:"" protobuf:"bytes,1,opt,name=lease_options,json=leaseOptions" json:"lease_options,omitempty"`
	// InternalData is a JSON object that is stored with the auth struct.
	// This will be sent back during a Renew/Revoke for storing internal data
	// used for those operations.
	InternalData string `sentinel:"" protobuf:"bytes,2,opt,name=internal_data,json=internalData" json:"internal_data,omitempty"`
	// DisplayName is a non-security sensitive identifier that is
	// applicable to this Auth. It is used for logging and prefixing
	// of dynamic secrets. For example, DisplayName may be "armon" for
	// the github credential backend. If the client token is used to
	// generate a SQL credential, the user may be "github-armon-uuid".
	// This is to help identify the source without using audit tables.
	DisplayName string `sentinel:"" protobuf:"bytes,3,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Policies is the list of policies that the authenticated user
	// is associated with.
	Policies []string `sentinel:"" protobuf:"bytes,4,rep,name=policies" json:"policies,omitempty"`
	// Metadata is used to attach arbitrary string-type metadata to
	// an authenticated user. This metadata will be outputted into the
	// audit log.
	Metadata map[string]string `sentinel:"" protobuf:"bytes,5,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ClientToken is the token that is generated for the authentication.
	// This will be filled in by Vault core when an auth structure is
	// returned. Setting this manually will have no effect.
	ClientToken string `sentinel:"" protobuf:"bytes,6,opt,name=client_token,json=clientToken" json:"client_token,omitempty"`
	// Accessor is the identifier for the ClientToken. This can be used
	// to perform management functionalities (especially revocation) when
	// ClientToken in the audit logs are obfuscated. Accessor can be used
	// to revoke a ClientToken and to lookup the capabilities of the ClientToken,
	// both without actually knowing the ClientToken.
	Accessor string `sentinel:"" protobuf:"bytes,7,opt,name=accessor" json:"accessor,omitempty"`
	// Period indicates that the token generated using this Auth object
	// should never expire. The token should be renewed within the duration
	// specified by this period.
	Period int64 `sentinel:"" protobuf:"varint,8,opt,name=period" json:"period,omitempty"`
	// Number of allowed uses of the issued token
	NumUses int64 `sentinel:"" protobuf:"varint,9,opt,name=num_uses,json=numUses" json:"num_uses,omitempty"`
	// EntityID is the identifier of the entity in identity store to which the
	// identity of the authenticating client belongs to.
	EntityID string `sentinel:"" protobuf:"bytes,10,opt,name=entity_id,json=entityId" json:"entity_id,omitempty"`
	// Alias is the information about the authenticated client returned by
	// the auth backend
	Alias *Alias `sentinel:"" protobuf:"bytes,11,opt,name=alias" json:"alias,omitempty"`
	// GroupAliases are the informational mappings of external groups which an
	// authenticated user belongs to. This is used to check if there are
	// mappings groups for the group aliases in identity store. For all the
	// matching groups, the entity ID of the user will be added.
	GroupAliases []*Alias `sentinel:"" protobuf:"bytes,12,rep,name=group_aliases,json=groupAliases" json:"group_aliases,omitempty"`
	// If set, restricts usage of the certificates to client IPs falling within
	// the range of the specified CIDR(s).
	BoundCidrs           []string `sentinel:"" protobuf:"bytes,13,rep,name=bound_cidrs,json=boundCidrs" json:"bound_cidrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Auth) Reset()         { *m = Auth{} }
func (m *Auth) String() string { return proto.CompactTextString(m) }
func (*Auth) ProtoMessage()    {}
func (*Auth) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{7}
}
func (m *Auth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Auth.Unmarshal(m, b)
}
func (m *Auth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Auth.Marshal(b, m, deterministic)
}
func (dst *Auth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auth.Merge(dst, src)
}
func (m *Auth) XXX_Size() int {
	return xxx_messageInfo_Auth.Size(m)
}
func (m *Auth) XXX_DiscardUnknown() {
	xxx_messageInfo_Auth.DiscardUnknown(m)
}

var xxx_messageInfo_Auth proto.InternalMessageInfo

func (m *Auth) GetLeaseOptions() *LeaseOptions {
	if m != nil {
		return m.LeaseOptions
	}
	return nil
}

func (m *Auth) GetInternalData() string {
	if m != nil {
		return m.InternalData
	}
	return ""
}

func (m *Auth) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Auth) GetPolicies() []string {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *Auth) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Auth) GetClientToken() string {
	if m != nil {
		return m.ClientToken
	}
	return ""
}

func (m *Auth) GetAccessor() string {
	if m != nil {
		return m.Accessor
	}
	return ""
}

func (m *Auth) GetPeriod() int64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *Auth) GetNumUses() int64 {
	if m != nil {
		return m.NumUses
	}
	return 0
}

func (m *Auth) GetEntityID() string {
	if m != nil {
		return m.EntityID
	}
	return ""
}

func (m *Auth) GetAlias() *Alias {
	if m != nil {
		return m.Alias
	}
	return nil
}

func (m *Auth) GetGroupAliases() []*Alias {
	if m != nil {
		return m.GroupAliases
	}
	return nil
}

func (m *Auth) GetBoundCidrs() []string {
	if m != nil {
		return m.BoundCidrs
	}
	return nil
}

type LeaseOptions struct {
	TTL                  int64                `sentinel:"" protobuf:"varint,1,opt,name=TTL" json:"TTL,omitempty"`
	Renewable            bool                 `sentinel:"" protobuf:"varint,2,opt,name=renewable" json:"renewable,omitempty"`
	Increment            int64                `sentinel:"" protobuf:"varint,3,opt,name=increment" json:"increment,omitempty"`
	IssueTime            *timestamp.Timestamp `sentinel:"" protobuf:"bytes,4,opt,name=issue_time,json=issueTime" json:"issue_time,omitempty"`
	MaxTTL               int64                `sentinel:"" protobuf:"varint,5,opt,name=MaxTTL" json:"MaxTTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *LeaseOptions) Reset()         { *m = LeaseOptions{} }
func (m *LeaseOptions) String() string { return proto.CompactTextString(m) }
func (*LeaseOptions) ProtoMessage()    {}
func (*LeaseOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{8}
}
func (m *LeaseOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LeaseOptions.Unmarshal(m, b)
}
func (m *LeaseOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LeaseOptions.Marshal(b, m, deterministic)
}
func (dst *LeaseOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseOptions.Merge(dst, src)
}
func (m *LeaseOptions) XXX_Size() int {
	return xxx_messageInfo_LeaseOptions.Size(m)
}
func (m *LeaseOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseOptions proto.InternalMessageInfo

func (m *LeaseOptions) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *LeaseOptions) GetRenewable() bool {
	if m != nil {
		return m.Renewable
	}
	return false
}

func (m *LeaseOptions) GetIncrement() int64 {
	if m != nil {
		return m.Increment
	}
	return 0
}

func (m *LeaseOptions) GetIssueTime() *timestamp.Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return nil
}

func (m *LeaseOptions) GetMaxTTL() int64 {
	if m != nil {
		return m.MaxTTL
	}
	return 0
}

type Secret struct {
	LeaseOptions *LeaseOptions `sentinel:"" protobuf:"bytes,1,opt,name=lease_options,json=leaseOptions" json:"lease_options,omitempty"`
	// InternalData is a JSON object that is stored with the secret.
	// This will be sent back during a Renew/Revoke for storing internal data
	// used for those operations.
	InternalData string `sentinel:"" protobuf:"bytes,2,opt,name=internal_data,json=internalData" json:"internal_data,omitempty"`
	// LeaseID is the ID returned to the user to manage this secret.
	// This is generated by Vault core. Any set value will be ignored.
	// For requests, this will always be blank.
	LeaseID              string   `sentinel:"" protobuf:"bytes,3,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Secret) Reset()         { *m = Secret{} }
func (m *Secret) String() string { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()    {}
func (*Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{9}
}
func (m *Secret) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Secret.Unmarshal(m, b)
}
func (m *Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Secret.Marshal(b, m, deterministic)
}
func (dst *Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Secret.Merge(dst, src)
}
func (m *Secret) XXX_Size() int {
	return xxx_messageInfo_Secret.Size(m)
}
func (m *Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_Secret proto.InternalMessageInfo

func (m *Secret) GetLeaseOptions() *LeaseOptions {
	if m != nil {
		return m.LeaseOptions
	}
	return nil
}

func (m *Secret) GetInternalData() string {
	if m != nil {
		return m.InternalData
	}
	return ""
}

func (m *Secret) GetLeaseID() string {
	if m != nil {
		return m.LeaseID
	}
	return ""
}

type Response struct {
	// Secret, if not nil, denotes that this response represents a secret.
	Secret *Secret `sentinel:"" protobuf:"bytes,1,opt,name=secret" json:"secret,omitempty"`
	// Auth, if not nil, contains the authentication information for
	// this response. This is only checked and means something for
	// credential backends.
	Auth *Auth `sentinel:"" protobuf:"bytes,2,opt,name=auth" json:"auth,omitempty"`
	// Response data is a JSON object that must have string keys. For
	// secrets, this data is sent down to the user as-is. To store internal
	// data that you don't want the user to see, store it in
	// Secret.InternalData.
	Data string `sentinel:"" protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// Redirect is an HTTP URL to redirect to for further authentication.
	// This is only valid for credential backends. This will be blanked
	// for any logical backend and ignored.
	Redirect string `sentinel:"" protobuf:"bytes,4,opt,name=redirect" json:"redirect,omitempty"`
	// Warnings allow operations or backends to return warnings in response
	// to user actions without failing the action outright.
	Warnings []string `sentinel:"" protobuf:"bytes,5,rep,name=warnings" json:"warnings,omitempty"`
	// Information for wrapping the response in a cubbyhole
	WrapInfo             *ResponseWrapInfo `sentinel:"" protobuf:"bytes,6,opt,name=wrap_info,json=wrapInfo" json:"wrap_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{10}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *Response) GetAuth() *Auth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *Response) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Response) GetRedirect() string {
	if m != nil {
		return m.Redirect
	}
	return ""
}

func (m *Response) GetWarnings() []string {
	if m != nil {
		return m.Warnings
	}
	return nil
}

func (m *Response) GetWrapInfo() *ResponseWrapInfo {
	if m != nil {
		return m.WrapInfo
	}
	return nil
}

type ResponseWrapInfo struct {
	// Setting to non-zero specifies that the response should be wrapped.
	// Specifies the desired TTL of the wrapping token.
	TTL int64 `sentinel:"" protobuf:"varint,1,opt,name=TTL" json:"TTL,omitempty"`
	// The token containing the wrapped response
	Token string `sentinel:"" protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	// The token accessor for the wrapped response token
	Accessor string `sentinel:"" protobuf:"bytes,3,opt,name=accessor" json:"accessor,omitempty"`
	// The creation time. This can be used with the TTL to figure out an
	// expected expiration.
	CreationTime *timestamp.Timestamp `sentinel:"" protobuf:"bytes,4,opt,name=creation_time,json=creationTime" json:"creation_time,omitempty"`
	// If the contained response is the output of a token creation call, the
	// created token's accessor will be accessible here
	WrappedAccessor string `sentinel:"" protobuf:"bytes,5,opt,name=wrapped_accessor,json=wrappedAccessor" json:"wrapped_accessor,omitempty"`
	// WrappedEntityID is the entity identifier of the caller who initiated the
	// wrapping request
	WrappedEntityID string `sentinel:"" protobuf:"bytes,6,opt,name=wrapped_entity_id,json=wrappedEntityID" json:"wrapped_entity_id,omitempty"`
	// The format to use. This doesn't get returned, it's only internal.
	Format string `sentinel:"" protobuf:"bytes,7,opt,name=format" json:"format,omitempty"`
	// CreationPath is the original request path that was used to create
	// the wrapped response.
	CreationPath string `sentinel:"" protobuf:"bytes,8,opt,name=creation_path,json=creationPath" json:"creation_path,omitempty"`
	// Controls seal wrapping behavior downstream for specific use cases
	SealWrap             bool     `sentinel:"" protobuf:"varint,9,opt,name=seal_wrap,json=sealWrap" json:"seal_wrap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseWrapInfo) Reset()         { *m = ResponseWrapInfo{} }
func (m *ResponseWrapInfo) String() string { return proto.CompactTextString(m) }
func (*ResponseWrapInfo) ProtoMessage()    {}
func (*ResponseWrapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{11}
}
func (m *ResponseWrapInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseWrapInfo.Unmarshal(m, b)
}
func (m *ResponseWrapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseWrapInfo.Marshal(b, m, deterministic)
}
func (dst *ResponseWrapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseWrapInfo.Merge(dst, src)
}
func (m *ResponseWrapInfo) XXX_Size() int {
	return xxx_messageInfo_ResponseWrapInfo.Size(m)
}
func (m *ResponseWrapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseWrapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseWrapInfo proto.InternalMessageInfo

func (m *ResponseWrapInfo) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *ResponseWrapInfo) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ResponseWrapInfo) GetAccessor() string {
	if m != nil {
		return m.Accessor
	}
	return ""
}

func (m *ResponseWrapInfo) GetCreationTime() *timestamp.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

func (m *ResponseWrapInfo) GetWrappedAccessor() string {
	if m != nil {
		return m.WrappedAccessor
	}
	return ""
}

func (m *ResponseWrapInfo) GetWrappedEntityID() string {
	if m != nil {
		return m.WrappedEntityID
	}
	return ""
}

func (m *ResponseWrapInfo) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ResponseWrapInfo) GetCreationPath() string {
	if m != nil {
		return m.CreationPath
	}
	return ""
}

func (m *ResponseWrapInfo) GetSealWrap() bool {
	if m != nil {
		return m.SealWrap
	}
	return false
}

type RequestWrapInfo struct {
	// Setting to non-zero specifies that the response should be wrapped.
	// Specifies the desired TTL of the wrapping token.
	TTL int64 `sentinel:"" protobuf:"varint,1,opt,name=TTL" json:"TTL,omitempty"`
	// The format to use for the wrapped response; if not specified it's a bare
	// token
	Format string `sentinel:"" protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
	// A flag to conforming backends that data for a given request should be
	// seal wrapped
	SealWrap             bool     `sentinel:"" protobuf:"varint,3,opt,name=seal_wrap,json=sealWrap" json:"seal_wrap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestWrapInfo) Reset()         { *m = RequestWrapInfo{} }
func (m *RequestWrapInfo) String() string { return proto.CompactTextString(m) }
func (*RequestWrapInfo) ProtoMessage()    {}
func (*RequestWrapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{12}
}
func (m *RequestWrapInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestWrapInfo.Unmarshal(m, b)
}
func (m *RequestWrapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestWrapInfo.Marshal(b, m, deterministic)
}
func (dst *RequestWrapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestWrapInfo.Merge(dst, src)
}
func (m *RequestWrapInfo) XXX_Size() int {
	return xxx_messageInfo_RequestWrapInfo.Size(m)
}
func (m *RequestWrapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestWrapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RequestWrapInfo proto.InternalMessageInfo

func (m *RequestWrapInfo) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *RequestWrapInfo) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *RequestWrapInfo) GetSealWrap() bool {
	if m != nil {
		return m.SealWrap
	}
	return false
}

// HandleRequestArgs is the args for HandleRequest method.
type HandleRequestArgs struct {
	StorageID            uint32   `sentinel:"" protobuf:"varint,1,opt,name=storage_id,json=storageId" json:"storage_id,omitempty"`
	Request              *Request `sentinel:"" protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HandleRequestArgs) Reset()         { *m = HandleRequestArgs{} }
func (m *HandleRequestArgs) String() string { return proto.CompactTextString(m) }
func (*HandleRequestArgs) ProtoMessage()    {}
func (*HandleRequestArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{13}
}
func (m *HandleRequestArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HandleRequestArgs.Unmarshal(m, b)
}
func (m *HandleRequestArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HandleRequestArgs.Marshal(b, m, deterministic)
}
func (dst *HandleRequestArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleRequestArgs.Merge(dst, src)
}
func (m *HandleRequestArgs) XXX_Size() int {
	return xxx_messageInfo_HandleRequestArgs.Size(m)
}
func (m *HandleRequestArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleRequestArgs.DiscardUnknown(m)
}

var xxx_messageInfo_HandleRequestArgs proto.InternalMessageInfo

func (m *HandleRequestArgs) GetStorageID() uint32 {
	if m != nil {
		return m.StorageID
	}
	return 0
}

func (m *HandleRequestArgs) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

// HandleRequestReply is the reply for HandleRequest method.
type HandleRequestReply struct {
	Response             *Response   `sentinel:"" protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
	Err                  *ProtoError `sentinel:"" protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HandleRequestReply) Reset()         { *m = HandleRequestReply{} }
func (m *HandleRequestReply) String() string { return proto.CompactTextString(m) }
func (*HandleRequestReply) ProtoMessage()    {}
func (*HandleRequestReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{14}
}
func (m *HandleRequestReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HandleRequestReply.Unmarshal(m, b)
}
func (m *HandleRequestReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HandleRequestReply.Marshal(b, m, deterministic)
}
func (dst *HandleRequestReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleRequestReply.Merge(dst, src)
}
func (m *HandleRequestReply) XXX_Size() int {
	return xxx_messageInfo_HandleRequestReply.Size(m)
}
func (m *HandleRequestReply) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleRequestReply.DiscardUnknown(m)
}

var xxx_messageInfo_HandleRequestReply proto.InternalMessageInfo

func (m *HandleRequestReply) GetResponse() *Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *HandleRequestReply) GetErr() *ProtoError {
	if m != nil {
		return m.Err
	}
	return nil
}

// SpecialPathsReply is the reply for SpecialPaths method.
type SpecialPathsReply struct {
	Paths                *Paths   `sentinel:"" protobuf:"bytes,1,opt,name=paths" json:"paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpecialPathsReply) Reset()         { *m = SpecialPathsReply{} }
func (m *SpecialPathsReply) String() string { return proto.CompactTextString(m) }
func (*SpecialPathsReply) ProtoMessage()    {}
func (*SpecialPathsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{15}
}
func (m *SpecialPathsReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SpecialPathsReply.Unmarshal(m, b)
}
func (m *SpecialPathsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SpecialPathsReply.Marshal(b, m, deterministic)
}
func (dst *SpecialPathsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialPathsReply.Merge(dst, src)
}
func (m *SpecialPathsReply) XXX_Size() int {
	return xxx_messageInfo_SpecialPathsReply.Size(m)
}
func (m *SpecialPathsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialPathsReply.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialPathsReply proto.InternalMessageInfo

func (m *SpecialPathsReply) GetPaths() *Paths {
	if m != nil {
		return m.Paths
	}
	return nil
}

// HandleExistenceCheckArgs is the args for HandleExistenceCheck method.
type HandleExistenceCheckArgs struct {
	StorageID            uint32   `sentinel:"" protobuf:"varint,1,opt,name=storage_id,json=storageId" json:"storage_id,omitempty"`
	Request              *Request `sentinel:"" protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HandleExistenceCheckArgs) Reset()         { *m = HandleExistenceCheckArgs{} }
func (m *HandleExistenceCheckArgs) String() string { return proto.CompactTextString(m) }
func (*HandleExistenceCheckArgs) ProtoMessage()    {}
func (*HandleExistenceCheckArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{16}
}
func (m *HandleExistenceCheckArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HandleExistenceCheckArgs.Unmarshal(m, b)
}
func (m *HandleExistenceCheckArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HandleExistenceCheckArgs.Marshal(b, m, deterministic)
}
func (dst *HandleExistenceCheckArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleExistenceCheckArgs.Merge(dst, src)
}
func (m *HandleExistenceCheckArgs) XXX_Size() int {
	return xxx_messageInfo_HandleExistenceCheckArgs.Size(m)
}
func (m *HandleExistenceCheckArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleExistenceCheckArgs.DiscardUnknown(m)
}

var xxx_messageInfo_HandleExistenceCheckArgs proto.InternalMessageInfo

func (m *HandleExistenceCheckArgs) GetStorageID() uint32 {
	if m != nil {
		return m.StorageID
	}
	return 0
}

func (m *HandleExistenceCheckArgs) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

// HandleExistenceCheckReply is the reply for HandleExistenceCheck method.
type HandleExistenceCheckReply struct {
	CheckFound           bool        `sentinel:"" protobuf:"varint,1,opt,name=check_found,json=checkFound" json:"check_found,omitempty"`
	Exists               bool        `sentinel:"" protobuf:"varint,2,opt,name=exists" json:"exists,omitempty"`
	Err                  *ProtoError `sentinel:"" protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HandleExistenceCheckReply) Reset()         { *m = HandleExistenceCheckReply{} }
func (m *HandleExistenceCheckReply) String() string { return proto.CompactTextString(m) }
func (*HandleExistenceCheckReply) ProtoMessage()    {}
func (*HandleExistenceCheckReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{17}
}
func (m *HandleExistenceCheckReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HandleExistenceCheckReply.Unmarshal(m, b)
}
func (m *HandleExistenceCheckReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HandleExistenceCheckReply.Marshal(b, m, deterministic)
}
func (dst *HandleExistenceCheckReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleExistenceCheckReply.Merge(dst, src)
}
func (m *HandleExistenceCheckReply) XXX_Size() int {
	return xxx_messageInfo_HandleExistenceCheckReply.Size(m)
}
func (m *HandleExistenceCheckReply) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleExistenceCheckReply.DiscardUnknown(m)
}

var xxx_messageInfo_HandleExistenceCheckReply proto.InternalMessageInfo

func (m *HandleExistenceCheckReply) GetCheckFound() bool {
	if m != nil {
		return m.CheckFound
	}
	return false
}

func (m *HandleExistenceCheckReply) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *HandleExistenceCheckReply) GetErr() *ProtoError {
	if m != nil {
		return m.Err
	}
	return nil
}

// SetupArgs is the args for Setup method.
type SetupArgs struct {
	BrokerID             uint32            `sentinel:"" protobuf:"varint,1,opt,name=broker_id,json=brokerId" json:"broker_id,omitempty"`
	Config               map[string]string `sentinel:"" protobuf:"bytes,2,rep,name=Config" json:"Config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	BackendUUID          string            `sentinel:"" protobuf:"bytes,3,opt,name=backendUUID" json:"backendUUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SetupArgs) Reset()         { *m = SetupArgs{} }
func (m *SetupArgs) String() string { return proto.CompactTextString(m) }
func (*SetupArgs) ProtoMessage()    {}
func (*SetupArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{18}
}
func (m *SetupArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetupArgs.Unmarshal(m, b)
}
func (m *SetupArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetupArgs.Marshal(b, m, deterministic)
}
func (dst *SetupArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetupArgs.Merge(dst, src)
}
func (m *SetupArgs) XXX_Size() int {
	return xxx_messageInfo_SetupArgs.Size(m)
}
func (m *SetupArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SetupArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SetupArgs proto.InternalMessageInfo

func (m *SetupArgs) GetBrokerID() uint32 {
	if m != nil {
		return m.BrokerID
	}
	return 0
}

func (m *SetupArgs) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *SetupArgs) GetBackendUUID() string {
	if m != nil {
		return m.BackendUUID
	}
	return ""
}

// SetupReply is the reply for Setup method.
type SetupReply struct {
	Err                  string   `sentinel:"" protobuf:"bytes,1,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetupReply) Reset()         { *m = SetupReply{} }
func (m *SetupReply) String() string { return proto.CompactTextString(m) }
func (*SetupReply) ProtoMessage()    {}
func (*SetupReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{19}
}
func (m *SetupReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetupReply.Unmarshal(m, b)
}
func (m *SetupReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetupReply.Marshal(b, m, deterministic)
}
func (dst *SetupReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetupReply.Merge(dst, src)
}
func (m *SetupReply) XXX_Size() int {
	return xxx_messageInfo_SetupReply.Size(m)
}
func (m *SetupReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetupReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetupReply proto.InternalMessageInfo

func (m *SetupReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

// TypeReply is the reply for the Type method.
type TypeReply struct {
	Type                 uint32   `sentinel:"" protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypeReply) Reset()         { *m = TypeReply{} }
func (m *TypeReply) String() string { return proto.CompactTextString(m) }
func (*TypeReply) ProtoMessage()    {}
func (*TypeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{20}
}
func (m *TypeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TypeReply.Unmarshal(m, b)
}
func (m *TypeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TypeReply.Marshal(b, m, deterministic)
}
func (dst *TypeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeReply.Merge(dst, src)
}
func (m *TypeReply) XXX_Size() int {
	return xxx_messageInfo_TypeReply.Size(m)
}
func (m *TypeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeReply.DiscardUnknown(m)
}

var xxx_messageInfo_TypeReply proto.InternalMessageInfo

func (m *TypeReply) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type InvalidateKeyArgs struct {
	Key                  string   `sentinel:"" protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvalidateKeyArgs) Reset()         { *m = InvalidateKeyArgs{} }
func (m *InvalidateKeyArgs) String() string { return proto.CompactTextString(m) }
func (*InvalidateKeyArgs) ProtoMessage()    {}
func (*InvalidateKeyArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{21}
}
func (m *InvalidateKeyArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InvalidateKeyArgs.Unmarshal(m, b)
}
func (m *InvalidateKeyArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InvalidateKeyArgs.Marshal(b, m, deterministic)
}
func (dst *InvalidateKeyArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidateKeyArgs.Merge(dst, src)
}
func (m *InvalidateKeyArgs) XXX_Size() int {
	return xxx_messageInfo_InvalidateKeyArgs.Size(m)
}
func (m *InvalidateKeyArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidateKeyArgs.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidateKeyArgs proto.InternalMessageInfo

func (m *InvalidateKeyArgs) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type StorageEntry struct {
	Key                  string   `sentinel:"" protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                []byte   `sentinel:"" protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	SealWrap             bool     `sentinel:"" protobuf:"varint,3,opt,name=seal_wrap,json=sealWrap" json:"seal_wrap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageEntry) Reset()         { *m = StorageEntry{} }
func (m *StorageEntry) String() string { return proto.CompactTextString(m) }
func (*StorageEntry) ProtoMessage()    {}
func (*StorageEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{22}
}
func (m *StorageEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageEntry.Unmarshal(m, b)
}
func (m *StorageEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageEntry.Marshal(b, m, deterministic)
}
func (dst *StorageEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageEntry.Merge(dst, src)
}
func (m *StorageEntry) XXX_Size() int {
	return xxx_messageInfo_StorageEntry.Size(m)
}
func (m *StorageEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageEntry.DiscardUnknown(m)
}

var xxx_messageInfo_StorageEntry proto.InternalMessageInfo

func (m *StorageEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StorageEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *StorageEntry) GetSealWrap() bool {
	if m != nil {
		return m.SealWrap
	}
	return false
}

type StorageListArgs struct {
	Prefix               string   `sentinel:"" protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageListArgs) Reset()         { *m = StorageListArgs{} }
func (m *StorageListArgs) String() string { return proto.CompactTextString(m) }
func (*StorageListArgs) ProtoMessage()    {}
func (*StorageListArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{23}
}
func (m *StorageListArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageListArgs.Unmarshal(m, b)
}
func (m *StorageListArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageListArgs.Marshal(b, m, deterministic)
}
func (dst *StorageListArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageListArgs.Merge(dst, src)
}
func (m *StorageListArgs) XXX_Size() int {
	return xxx_messageInfo_StorageListArgs.Size(m)
}
func (m *StorageListArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageListArgs.DiscardUnknown(m)
}

var xxx_messageInfo_StorageListArgs proto.InternalMessageInfo

func (m *StorageListArgs) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type StorageListReply struct {
	Keys                 []string `sentinel:"" protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Err                  string   `sentinel:"" protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageListReply) Reset()         { *m = StorageListReply{} }
func (m *StorageListReply) String() string { return proto.CompactTextString(m) }
func (*StorageListReply) ProtoMessage()    {}
func (*StorageListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{24}
}
func (m *StorageListReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageListReply.Unmarshal(m, b)
}
func (m *StorageListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageListReply.Marshal(b, m, deterministic)
}
func (dst *StorageListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageListReply.Merge(dst, src)
}
func (m *StorageListReply) XXX_Size() int {
	return xxx_messageInfo_StorageListReply.Size(m)
}
func (m *StorageListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageListReply.DiscardUnknown(m)
}

var xxx_messageInfo_StorageListReply proto.InternalMessageInfo

func (m *StorageListReply) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *StorageListReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type StorageGetArgs struct {
	Key                  string   `sentinel:"" protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageGetArgs) Reset()         { *m = StorageGetArgs{} }
func (m *StorageGetArgs) String() string { return proto.CompactTextString(m) }
func (*StorageGetArgs) ProtoMessage()    {}
func (*StorageGetArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{25}
}
func (m *StorageGetArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageGetArgs.Unmarshal(m, b)
}
func (m *StorageGetArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageGetArgs.Marshal(b, m, deterministic)
}
func (dst *StorageGetArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageGetArgs.Merge(dst, src)
}
func (m *StorageGetArgs) XXX_Size() int {
	return xxx_messageInfo_StorageGetArgs.Size(m)
}
func (m *StorageGetArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageGetArgs.DiscardUnknown(m)
}

var xxx_messageInfo_StorageGetArgs proto.InternalMessageInfo

func (m *StorageGetArgs) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type StorageGetReply struct {
	Entry                *StorageEntry `sentinel:"" protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
	Err                  string        `sentinel:"" protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StorageGetReply) Reset()         { *m = StorageGetReply{} }
func (m *StorageGetReply) String() string { return proto.CompactTextString(m) }
func (*StorageGetReply) ProtoMessage()    {}
func (*StorageGetReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{26}
}
func (m *StorageGetReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageGetReply.Unmarshal(m, b)
}
func (m *StorageGetReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageGetReply.Marshal(b, m, deterministic)
}
func (dst *StorageGetReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageGetReply.Merge(dst, src)
}
func (m *StorageGetReply) XXX_Size() int {
	return xxx_messageInfo_StorageGetReply.Size(m)
}
func (m *StorageGetReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageGetReply.DiscardUnknown(m)
}

var xxx_messageInfo_StorageGetReply proto.InternalMessageInfo

func (m *StorageGetReply) GetEntry() *StorageEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *StorageGetReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type StoragePutArgs struct {
	Entry                *StorageEntry `sentinel:"" protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StoragePutArgs) Reset()         { *m = StoragePutArgs{} }
func (m *StoragePutArgs) String() string { return proto.CompactTextString(m) }
func (*StoragePutArgs) ProtoMessage()    {}
func (*StoragePutArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{27}
}
func (m *StoragePutArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoragePutArgs.Unmarshal(m, b)
}
func (m *StoragePutArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoragePutArgs.Marshal(b, m, deterministic)
}
func (dst *StoragePutArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoragePutArgs.Merge(dst, src)
}
func (m *StoragePutArgs) XXX_Size() int {
	return xxx_messageInfo_StoragePutArgs.Size(m)
}
func (m *StoragePutArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_StoragePutArgs.DiscardUnknown(m)
}

var xxx_messageInfo_StoragePutArgs proto.InternalMessageInfo

func (m *StoragePutArgs) GetEntry() *StorageEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type StoragePutReply struct {
	Err                  string   `sentinel:"" protobuf:"bytes,1,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoragePutReply) Reset()         { *m = StoragePutReply{} }
func (m *StoragePutReply) String() string { return proto.CompactTextString(m) }
func (*StoragePutReply) ProtoMessage()    {}
func (*StoragePutReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{28}
}
func (m *StoragePutReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoragePutReply.Unmarshal(m, b)
}
func (m *StoragePutReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoragePutReply.Marshal(b, m, deterministic)
}
func (dst *StoragePutReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoragePutReply.Merge(dst, src)
}
func (m *StoragePutReply) XXX_Size() int {
	return xxx_messageInfo_StoragePutReply.Size(m)
}
func (m *StoragePutReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StoragePutReply.DiscardUnknown(m)
}

var xxx_messageInfo_StoragePutReply proto.InternalMessageInfo

func (m *StoragePutReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type StorageDeleteArgs struct {
	Key                  string   `sentinel:"" protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageDeleteArgs) Reset()         { *m = StorageDeleteArgs{} }
func (m *StorageDeleteArgs) String() string { return proto.CompactTextString(m) }
func (*StorageDeleteArgs) ProtoMessage()    {}
func (*StorageDeleteArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{29}
}
func (m *StorageDeleteArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageDeleteArgs.Unmarshal(m, b)
}
func (m *StorageDeleteArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageDeleteArgs.Marshal(b, m, deterministic)
}
func (dst *StorageDeleteArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeleteArgs.Merge(dst, src)
}
func (m *StorageDeleteArgs) XXX_Size() int {
	return xxx_messageInfo_StorageDeleteArgs.Size(m)
}
func (m *StorageDeleteArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeleteArgs.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeleteArgs proto.InternalMessageInfo

func (m *StorageDeleteArgs) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type StorageDeleteReply struct {
	Err                  string   `sentinel:"" protobuf:"bytes,1,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageDeleteReply) Reset()         { *m = StorageDeleteReply{} }
func (m *StorageDeleteReply) String() string { return proto.CompactTextString(m) }
func (*StorageDeleteReply) ProtoMessage()    {}
func (*StorageDeleteReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{30}
}
func (m *StorageDeleteReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageDeleteReply.Unmarshal(m, b)
}
func (m *StorageDeleteReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageDeleteReply.Marshal(b, m, deterministic)
}
func (dst *StorageDeleteReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeleteReply.Merge(dst, src)
}
func (m *StorageDeleteReply) XXX_Size() int {
	return xxx_messageInfo_StorageDeleteReply.Size(m)
}
func (m *StorageDeleteReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeleteReply.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeleteReply proto.InternalMessageInfo

func (m *StorageDeleteReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type TTLReply struct {
	TTL                  int64    `sentinel:"" protobuf:"varint,1,opt,name=TTL" json:"TTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTLReply) Reset()         { *m = TTLReply{} }
func (m *TTLReply) String() string { return proto.CompactTextString(m) }
func (*TTLReply) ProtoMessage()    {}
func (*TTLReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{31}
}
func (m *TTLReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TTLReply.Unmarshal(m, b)
}
func (m *TTLReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TTLReply.Marshal(b, m, deterministic)
}
func (dst *TTLReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTLReply.Merge(dst, src)
}
func (m *TTLReply) XXX_Size() int {
	return xxx_messageInfo_TTLReply.Size(m)
}
func (m *TTLReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TTLReply.DiscardUnknown(m)
}

var xxx_messageInfo_TTLReply proto.InternalMessageInfo

func (m *TTLReply) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

type SudoPrivilegeArgs struct {
	Path                 string   `sentinel:"" protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Token                string   `sentinel:"" protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SudoPrivilegeArgs) Reset()         { *m = SudoPrivilegeArgs{} }
func (m *SudoPrivilegeArgs) String() string { return proto.CompactTextString(m) }
func (*SudoPrivilegeArgs) ProtoMessage()    {}
func (*SudoPrivilegeArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{32}
}
func (m *SudoPrivilegeArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SudoPrivilegeArgs.Unmarshal(m, b)
}
func (m *SudoPrivilegeArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SudoPrivilegeArgs.Marshal(b, m, deterministic)
}
func (dst *SudoPrivilegeArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SudoPrivilegeArgs.Merge(dst, src)
}
func (m *SudoPrivilegeArgs) XXX_Size() int {
	return xxx_messageInfo_SudoPrivilegeArgs.Size(m)
}
func (m *SudoPrivilegeArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SudoPrivilegeArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SudoPrivilegeArgs proto.InternalMessageInfo

func (m *SudoPrivilegeArgs) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *SudoPrivilegeArgs) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SudoPrivilegeReply struct {
	Sudo                 bool     `sentinel:"" protobuf:"varint,1,opt,name=sudo" json:"sudo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SudoPrivilegeReply) Reset()         { *m = SudoPrivilegeReply{} }
func (m *SudoPrivilegeReply) String() string { return proto.CompactTextString(m) }
func (*SudoPrivilegeReply) ProtoMessage()    {}
func (*SudoPrivilegeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{33}
}
func (m *SudoPrivilegeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SudoPrivilegeReply.Unmarshal(m, b)
}
func (m *SudoPrivilegeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SudoPrivilegeReply.Marshal(b, m, deterministic)
}
func (dst *SudoPrivilegeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SudoPrivilegeReply.Merge(dst, src)
}
func (m *SudoPrivilegeReply) XXX_Size() int {
	return xxx_messageInfo_SudoPrivilegeReply.Size(m)
}
func (m *SudoPrivilegeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SudoPrivilegeReply.DiscardUnknown(m)
}

var xxx_messageInfo_SudoPrivilegeReply proto.InternalMessageInfo

func (m *SudoPrivilegeReply) GetSudo() bool {
	if m != nil {
		return m.Sudo
	}
	return false
}

type TaintedReply struct {
	Tainted              bool     `sentinel:"" protobuf:"varint,1,opt,name=tainted" json:"tainted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaintedReply) Reset()         { *m = TaintedReply{} }
func (m *TaintedReply) String() string { return proto.CompactTextString(m) }
func (*TaintedReply) ProtoMessage()    {}
func (*TaintedReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{34}
}
func (m *TaintedReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TaintedReply.Unmarshal(m, b)
}
func (m *TaintedReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TaintedReply.Marshal(b, m, deterministic)
}
func (dst *TaintedReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaintedReply.Merge(dst, src)
}
func (m *TaintedReply) XXX_Size() int {
	return xxx_messageInfo_TaintedReply.Size(m)
}
func (m *TaintedReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TaintedReply.DiscardUnknown(m)
}

var xxx_messageInfo_TaintedReply proto.InternalMessageInfo

func (m *TaintedReply) GetTainted() bool {
	if m != nil {
		return m.Tainted
	}
	return false
}

type CachingDisabledReply struct {
	Disabled             bool     `sentinel:"" protobuf:"varint,1,opt,name=disabled" json:"disabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CachingDisabledReply) Reset()         { *m = CachingDisabledReply{} }
func (m *CachingDisabledReply) String() string { return proto.CompactTextString(m) }
func (*CachingDisabledReply) ProtoMessage()    {}
func (*CachingDisabledReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{35}
}
func (m *CachingDisabledReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CachingDisabledReply.Unmarshal(m, b)
}
func (m *CachingDisabledReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CachingDisabledReply.Marshal(b, m, deterministic)
}
func (dst *CachingDisabledReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CachingDisabledReply.Merge(dst, src)
}
func (m *CachingDisabledReply) XXX_Size() int {
	return xxx_messageInfo_CachingDisabledReply.Size(m)
}
func (m *CachingDisabledReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CachingDisabledReply.DiscardUnknown(m)
}

var xxx_messageInfo_CachingDisabledReply proto.InternalMessageInfo

func (m *CachingDisabledReply) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

type ReplicationStateReply struct {
	State                int32    `sentinel:"" protobuf:"varint,1,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationStateReply) Reset()         { *m = ReplicationStateReply{} }
func (m *ReplicationStateReply) String() string { return proto.CompactTextString(m) }
func (*ReplicationStateReply) ProtoMessage()    {}
func (*ReplicationStateReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{36}
}
func (m *ReplicationStateReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReplicationStateReply.Unmarshal(m, b)
}
func (m *ReplicationStateReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReplicationStateReply.Marshal(b, m, deterministic)
}
func (dst *ReplicationStateReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationStateReply.Merge(dst, src)
}
func (m *ReplicationStateReply) XXX_Size() int {
	return xxx_messageInfo_ReplicationStateReply.Size(m)
}
func (m *ReplicationStateReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationStateReply.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationStateReply proto.InternalMessageInfo

func (m *ReplicationStateReply) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type ResponseWrapDataArgs struct {
	Data                 string   `sentinel:"" protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	TTL                  int64    `sentinel:"" protobuf:"varint,2,opt,name=TTL" json:"TTL,omitempty"`
	JWT                  bool     `sentinel:"" protobuf:"varint,3,opt,name=JWT" json:"JWT,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseWrapDataArgs) Reset()         { *m = ResponseWrapDataArgs{} }
func (m *ResponseWrapDataArgs) String() string { return proto.CompactTextString(m) }
func (*ResponseWrapDataArgs) ProtoMessage()    {}
func (*ResponseWrapDataArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{37}
}
func (m *ResponseWrapDataArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseWrapDataArgs.Unmarshal(m, b)
}
func (m *ResponseWrapDataArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseWrapDataArgs.Marshal(b, m, deterministic)
}
func (dst *ResponseWrapDataArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseWrapDataArgs.Merge(dst, src)
}
func (m *ResponseWrapDataArgs) XXX_Size() int {
	return xxx_messageInfo_ResponseWrapDataArgs.Size(m)
}
func (m *ResponseWrapDataArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseWrapDataArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseWrapDataArgs proto.InternalMessageInfo

func (m *ResponseWrapDataArgs) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ResponseWrapDataArgs) GetTTL() int64 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *ResponseWrapDataArgs) GetJWT() bool {
	if m != nil {
		return m.JWT
	}
	return false
}

type ResponseWrapDataReply struct {
	WrapInfo             *ResponseWrapInfo `sentinel:"" protobuf:"bytes,1,opt,name=wrap_info,json=wrapInfo" json:"wrap_info,omitempty"`
	Err                  string            `sentinel:"" protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ResponseWrapDataReply) Reset()         { *m = ResponseWrapDataReply{} }
func (m *ResponseWrapDataReply) String() string { return proto.CompactTextString(m) }
func (*ResponseWrapDataReply) ProtoMessage()    {}
func (*ResponseWrapDataReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{38}
}
func (m *ResponseWrapDataReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseWrapDataReply.Unmarshal(m, b)
}
func (m *ResponseWrapDataReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseWrapDataReply.Marshal(b, m, deterministic)
}
func (dst *ResponseWrapDataReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseWrapDataReply.Merge(dst, src)
}
func (m *ResponseWrapDataReply) XXX_Size() int {
	return xxx_messageInfo_ResponseWrapDataReply.Size(m)
}
func (m *ResponseWrapDataReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseWrapDataReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseWrapDataReply proto.InternalMessageInfo

func (m *ResponseWrapDataReply) GetWrapInfo() *ResponseWrapInfo {
	if m != nil {
		return m.WrapInfo
	}
	return nil
}

func (m *ResponseWrapDataReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type MlockEnabledReply struct {
	Enabled              bool     `sentinel:"" protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MlockEnabledReply) Reset()         { *m = MlockEnabledReply{} }
func (m *MlockEnabledReply) String() string { return proto.CompactTextString(m) }
func (*MlockEnabledReply) ProtoMessage()    {}
func (*MlockEnabledReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{39}
}
func (m *MlockEnabledReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MlockEnabledReply.Unmarshal(m, b)
}
func (m *MlockEnabledReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MlockEnabledReply.Marshal(b, m, deterministic)
}
func (dst *MlockEnabledReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MlockEnabledReply.Merge(dst, src)
}
func (m *MlockEnabledReply) XXX_Size() int {
	return xxx_messageInfo_MlockEnabledReply.Size(m)
}
func (m *MlockEnabledReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MlockEnabledReply.DiscardUnknown(m)
}

var xxx_messageInfo_MlockEnabledReply proto.InternalMessageInfo

func (m *MlockEnabledReply) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type LocalMountReply struct {
	Local                bool     `sentinel:"" protobuf:"varint,1,opt,name=local" json:"local,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalMountReply) Reset()         { *m = LocalMountReply{} }
func (m *LocalMountReply) String() string { return proto.CompactTextString(m) }
func (*LocalMountReply) ProtoMessage()    {}
func (*LocalMountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{40}
}
func (m *LocalMountReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocalMountReply.Unmarshal(m, b)
}
func (m *LocalMountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocalMountReply.Marshal(b, m, deterministic)
}
func (dst *LocalMountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalMountReply.Merge(dst, src)
}
func (m *LocalMountReply) XXX_Size() int {
	return xxx_messageInfo_LocalMountReply.Size(m)
}
func (m *LocalMountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalMountReply.DiscardUnknown(m)
}

var xxx_messageInfo_LocalMountReply proto.InternalMessageInfo

func (m *LocalMountReply) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

type EntityInfoArgs struct {
	EntityID             string   `sentinel:"" protobuf:"bytes,1,opt,name=entity_id,json=entityId" json:"entity_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntityInfoArgs) Reset()         { *m = EntityInfoArgs{} }
func (m *EntityInfoArgs) String() string { return proto.CompactTextString(m) }
func (*EntityInfoArgs) ProtoMessage()    {}
func (*EntityInfoArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{41}
}
func (m *EntityInfoArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EntityInfoArgs.Unmarshal(m, b)
}
func (m *EntityInfoArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EntityInfoArgs.Marshal(b, m, deterministic)
}
func (dst *EntityInfoArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityInfoArgs.Merge(dst, src)
}
func (m *EntityInfoArgs) XXX_Size() int {
	return xxx_messageInfo_EntityInfoArgs.Size(m)
}
func (m *EntityInfoArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityInfoArgs.DiscardUnknown(m)
}

var xxx_messageInfo_EntityInfoArgs proto.InternalMessageInfo

func (m *EntityInfoArgs) GetEntityID() string {
	if m != nil {
		return m.EntityID
	}
	return ""
}

type EntityInfoReply struct {
	Entity               *Entity  `sentinel:"" protobuf:"bytes,1,opt,name=entity" json:"entity,omitempty"`
	Err                  string   `sentinel:"" protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntityInfoReply) Reset()         { *m = EntityInfoReply{} }
func (m *EntityInfoReply) String() string { return proto.CompactTextString(m) }
func (*EntityInfoReply) ProtoMessage()    {}
func (*EntityInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{42}
}
func (m *EntityInfoReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EntityInfoReply.Unmarshal(m, b)
}
func (m *EntityInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EntityInfoReply.Marshal(b, m, deterministic)
}
func (dst *EntityInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityInfoReply.Merge(dst, src)
}
func (m *EntityInfoReply) XXX_Size() int {
	return xxx_messageInfo_EntityInfoReply.Size(m)
}
func (m *EntityInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_EntityInfoReply proto.InternalMessageInfo

func (m *EntityInfoReply) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *EntityInfoReply) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type Connection struct {
	// RemoteAddr is the network address that sent the request.
	RemoteAddr           string   `sentinel:"" protobuf:"bytes,1,opt,name=remote_addr,json=remoteAddr" json:"remote_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_backend_1a730c5561cd075d, []int{43}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Connection.Unmarshal(m, b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
}
func (dst *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(dst, src)
}
func (m *Connection) XXX_Size() int {
	return xxx_messageInfo_Connection.Size(m)
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetRemoteAddr() string {
	if m != nil {
		return m.RemoteAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "pb.Empty")
	proto.RegisterType((*Header)(nil), "pb.Header")
	proto.RegisterType((*ProtoError)(nil), "pb.ProtoError")
	proto.RegisterType((*Paths)(nil), "pb.Paths")
	proto.RegisterType((*Request)(nil), "pb.Request")
	proto.RegisterMapType((map[string]*Header)(nil), "pb.Request.HeadersEntry")
	proto.RegisterType((*Entity)(nil), "pb.Entity")
	proto.RegisterType((*Alias)(nil), "pb.Alias")
	proto.RegisterType((*Auth)(nil), "pb.Auth")
	proto.RegisterMapType((map[string]string)(nil), "pb.Auth.MetadataEntry")
	proto.RegisterType((*LeaseOptions)(nil), "pb.LeaseOptions")
	proto.RegisterType((*Secret)(nil), "pb.Secret")
	proto.RegisterType((*Response)(nil), "pb.Response")
	proto.RegisterType((*ResponseWrapInfo)(nil), "pb.ResponseWrapInfo")
	proto.RegisterType((*RequestWrapInfo)(nil), "pb.RequestWrapInfo")
	proto.RegisterType((*HandleRequestArgs)(nil), "pb.HandleRequestArgs")
	proto.RegisterType((*HandleRequestReply)(nil), "pb.HandleRequestReply")
	proto.RegisterType((*SpecialPathsReply)(nil), "pb.SpecialPathsReply")
	proto.RegisterType((*HandleExistenceCheckArgs)(nil), "pb.HandleExistenceCheckArgs")
	proto.RegisterType((*HandleExistenceCheckReply)(nil), "pb.HandleExistenceCheckReply")
	proto.RegisterType((*SetupArgs)(nil), "pb.SetupArgs")
	proto.RegisterMapType((map[string]string)(nil), "pb.SetupArgs.ConfigEntry")
	proto.RegisterType((*SetupReply)(nil), "pb.SetupReply")
	proto.RegisterType((*TypeReply)(nil), "pb.TypeReply")
	proto.RegisterType((*InvalidateKeyArgs)(nil), "pb.InvalidateKeyArgs")
	proto.RegisterType((*StorageEntry)(nil), "pb.StorageEntry")
	proto.RegisterType((*StorageListArgs)(nil), "pb.StorageListArgs")
	proto.RegisterType((*StorageListReply)(nil), "pb.StorageListReply")
	proto.RegisterType((*StorageGetArgs)(nil), "pb.StorageGetArgs")
	proto.RegisterType((*StorageGetReply)(nil), "pb.StorageGetReply")
	proto.RegisterType((*StoragePutArgs)(nil), "pb.StoragePutArgs")
	proto.RegisterType((*StoragePutReply)(nil), "pb.StoragePutReply")
	proto.RegisterType((*StorageDeleteArgs)(nil), "pb.StorageDeleteArgs")
	proto.RegisterType((*StorageDeleteReply)(nil), "pb.StorageDeleteReply")
	proto.RegisterType((*TTLReply)(nil), "pb.TTLReply")
	proto.RegisterType((*SudoPrivilegeArgs)(nil), "pb.SudoPrivilegeArgs")
	proto.RegisterType((*SudoPrivilegeReply)(nil), "pb.SudoPrivilegeReply")
	proto.RegisterType((*TaintedReply)(nil), "pb.TaintedReply")
	proto.RegisterType((*CachingDisabledReply)(nil), "pb.CachingDisabledReply")
	proto.RegisterType((*ReplicationStateReply)(nil), "pb.ReplicationStateReply")
	proto.RegisterType((*ResponseWrapDataArgs)(nil), "pb.ResponseWrapDataArgs")
	proto.RegisterType((*ResponseWrapDataReply)(nil), "pb.ResponseWrapDataReply")
	proto.RegisterType((*MlockEnabledReply)(nil), "pb.MlockEnabledReply")
	proto.RegisterType((*LocalMountReply)(nil), "pb.LocalMountReply")
	proto.RegisterType((*EntityInfoArgs)(nil), "pb.EntityInfoArgs")
	proto.RegisterType((*EntityInfoReply)(nil), "pb.EntityInfoReply")
	proto.RegisterType((*Connection)(nil), "pb.Connection")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackendClient is the client API for Backend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackendClient interface {
	// HandleRequest is used to handle a request and generate a response.
	// The plugins must check the operation type and handle appropriately.
	HandleRequest(ctx context.Context, in *HandleRequestArgs, opts ...grpc.CallOption) (*HandleRequestReply, error)
	// SpecialPaths is a list of paths that are special in some way.
	// See PathType for the types of special paths. The key is the type
	// of the special path, and the value is a list of paths for this type.
	// This is not a regular expression but is an exact match. If the path
	// ends in '*' then it is a prefix-based match. The '*' can only appear
	// at the end.
	SpecialPaths(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SpecialPathsReply, error)
	// HandleExistenceCheck is used to handle a request and generate a response
	// indicating whether the given path exists or not; this is used to
	// understand whether the request must have a Create or Update capability
	// ACL applied. The first bool indicates whether an existence check
	// function was found for the backend; the second indicates whether, if an
	// existence check function was found, the item exists or not.
	HandleExistenceCheck(ctx context.Context, in *HandleExistenceCheckArgs, opts ...grpc.CallOption) (*HandleExistenceCheckReply, error)
	// Cleanup is invoked during an unmount of a backend to allow it to
	// handle any cleanup like connection closing or releasing of file handles.
	// Cleanup is called right before Vault closes the plugin process.
	Cleanup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// InvalidateKey may be invoked when an object is modified that belongs
	// to the backend. The backend can use this to clear any caches or reset
	// internal state as needed.
	InvalidateKey(ctx context.Context, in *InvalidateKeyArgs, opts ...grpc.CallOption) (*Empty, error)
	// Setup is used to set up the backend based on the provided backend
	// configuration. The plugin's setup implementation should use the provided
	// broker_id to create a connection back to Vault for use with the Storage
	// and SystemView clients.
	Setup(ctx context.Context, in *SetupArgs, opts ...grpc.CallOption) (*SetupReply, error)
	// Type returns the BackendType for the particular backend
	Type(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TypeReply, error)
}

type backendClient struct {
	cc *grpc.ClientConn
}

func NewBackendClient(cc *grpc.ClientConn) BackendClient {
	return &backendClient{cc}
}

func (c *backendClient) HandleRequest(ctx context.Context, in *HandleRequestArgs, opts ...grpc.CallOption) (*HandleRequestReply, error) {
	out := new(HandleRequestReply)
	err := c.cc.Invoke(ctx, "/pb.Backend/HandleRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) SpecialPaths(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SpecialPathsReply, error) {
	out := new(SpecialPathsReply)
	err := c.cc.Invoke(ctx, "/pb.Backend/SpecialPaths", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) HandleExistenceCheck(ctx context.Context, in *HandleExistenceCheckArgs, opts ...grpc.CallOption) (*HandleExistenceCheckReply, error) {
	out := new(HandleExistenceCheckReply)
	err := c.cc.Invoke(ctx, "/pb.Backend/HandleExistenceCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) Cleanup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.Backend/Cleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) InvalidateKey(ctx context.Context, in *InvalidateKeyArgs, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.Backend/InvalidateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) Setup(ctx context.Context, in *SetupArgs, opts ...grpc.CallOption) (*SetupReply, error) {
	out := new(SetupReply)
	err := c.cc.Invoke(ctx, "/pb.Backend/Setup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendClient) Type(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TypeReply, error) {
	out := new(TypeReply)
	err := c.cc.Invoke(ctx, "/pb.Backend/Type", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendServer is the server API for Backend service.
type BackendServer interface {
	// HandleRequest is used to handle a request and generate a response.
	// The plugins must check the operation type and handle appropriately.
	HandleRequest(context.Context, *HandleRequestArgs) (*HandleRequestReply, error)
	// SpecialPaths is a list of paths that are special in some way.
	// See PathType for the types of special paths. The key is the type
	// of the special path, and the value is a list of paths for this type.
	// This is not a regular expression but is an exact match. If the path
	// ends in '*' then it is a prefix-based match. The '*' can only appear
	// at the end.
	SpecialPaths(context.Context, *Empty) (*SpecialPathsReply, error)
	// HandleExistenceCheck is used to handle a request and generate a response
	// indicating whether the given path exists or not; this is used to
	// understand whether the request must have a Create or Update capability
	// ACL applied. The first bool indicates whether an existence check
	// function was found for the backend; the second indicates whether, if an
	// existence check function was found, the item exists or not.
	HandleExistenceCheck(context.Context, *HandleExistenceCheckArgs) (*HandleExistenceCheckReply, error)
	// Cleanup is invoked during an unmount of a backend to allow it to
	// handle any cleanup like connection closing or releasing of file handles.
	// Cleanup is called right before Vault closes the plugin process.
	Cleanup(context.Context, *Empty) (*Empty, error)
	// InvalidateKey may be invoked when an object is modified that belongs
	// to the backend. The backend can use this to clear any caches or reset
	// internal state as needed.
	InvalidateKey(context.Context, *InvalidateKeyArgs) (*Empty, error)
	// Setup is used to set up the backend based on the provided backend
	// configuration. The plugin's setup implementation should use the provided
	// broker_id to create a connection back to Vault for use with the Storage
	// and SystemView clients.
	Setup(context.Context, *SetupArgs) (*SetupReply, error)
	// Type returns the BackendType for the particular backend
	Type(context.Context, *Empty) (*TypeReply, error)
}

func RegisterBackendServer(s *grpc.Server, srv BackendServer) {
	s.RegisterService(&_Backend_serviceDesc, srv)
}

func _Backend_HandleRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequestArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).HandleRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/HandleRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).HandleRequest(ctx, req.(*HandleRequestArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_SpecialPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).SpecialPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/SpecialPaths",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).SpecialPaths(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_HandleExistenceCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleExistenceCheckArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).HandleExistenceCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/HandleExistenceCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).HandleExistenceCheck(ctx, req.(*HandleExistenceCheckArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).Cleanup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_InvalidateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateKeyArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).InvalidateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/InvalidateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).InvalidateKey(ctx, req.(*InvalidateKeyArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_Setup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).Setup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/Setup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).Setup(ctx, req.(*SetupArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backend_Type_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServer).Type(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Backend/Type",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServer).Type(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Backend_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Backend",
	HandlerType: (*BackendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleRequest",
			Handler:    _Backend_HandleRequest_Handler,
		},
		{
			MethodName: "SpecialPaths",
			Handler:    _Backend_SpecialPaths_Handler,
		},
		{
			MethodName: "HandleExistenceCheck",
			Handler:    _Backend_HandleExistenceCheck_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _Backend_Cleanup_Handler,
		},
		{
			MethodName: "InvalidateKey",
			Handler:    _Backend_InvalidateKey_Handler,
		},
		{
			MethodName: "Setup",
			Handler:    _Backend_Setup_Handler,
		},
		{
			MethodName: "Type",
			Handler:    _Backend_Type_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "logical/plugin/pb/backend.proto",
}

// StorageClient is the client API for Storage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StorageClient interface {
	List(ctx context.Context, in *StorageListArgs, opts ...grpc.CallOption) (*StorageListReply, error)
	Get(ctx context.Context, in *StorageGetArgs, opts ...grpc.CallOption) (*StorageGetReply, error)
	Put(ctx context.Context, in *StoragePutArgs, opts ...grpc.CallOption) (*StoragePutReply, error)
	Delete(ctx context.Context, in *StorageDeleteArgs, opts ...grpc.CallOption) (*StorageDeleteReply, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) List(ctx context.Context, in *StorageListArgs, opts ...grpc.CallOption) (*StorageListReply, error) {
	out := new(StorageListReply)
	err := c.cc.Invoke(ctx, "/pb.Storage/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Get(ctx context.Context, in *StorageGetArgs, opts ...grpc.CallOption) (*StorageGetReply, error) {
	out := new(StorageGetReply)
	err := c.cc.Invoke(ctx, "/pb.Storage/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Put(ctx context.Context, in *StoragePutArgs, opts ...grpc.CallOption) (*StoragePutReply, error) {
	out := new(StoragePutReply)
	err := c.cc.Invoke(ctx, "/pb.Storage/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *StorageDeleteArgs, opts ...grpc.CallOption) (*StorageDeleteReply, error) {
	out := new(StorageDeleteReply)
	err := c.cc.Invoke(ctx, "/pb.Storage/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageServer is the server API for Storage service.
type StorageServer interface {
	List(context.Context, *StorageListArgs) (*StorageListReply, error)
	Get(context.Context, *StorageGetArgs) (*StorageGetReply, error)
	Put(context.Context, *StoragePutArgs) (*StoragePutReply, error)
	Delete(context.Context, *StorageDeleteArgs) (*StorageDeleteReply, error)
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageListArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Storage/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).List(ctx, req.(*StorageListArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageGetArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Storage/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Get(ctx, req.(*StorageGetArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoragePutArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Storage/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Put(ctx, req.(*StoragePutArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageDeleteArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Storage/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Delete(ctx, req.(*StorageDeleteArgs))
	}
	return interceptor(ctx, in, info, handler)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Storage_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Storage_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Storage_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "logical/plugin/pb/backend.proto",
}

// SystemViewClient is the client API for SystemView service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SystemViewClient interface {
	// DefaultLeaseTTL returns the default lease TTL set in Vault configuration
	DefaultLeaseTTL(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TTLReply, error)
	// MaxLeaseTTL returns the max lease TTL set in Vault configuration; backend
	// authors should take care not to issue credentials that last longer than
	// this value, as Vault will revoke them
	MaxLeaseTTL(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TTLReply, error)
	// SudoPrivilege returns true if given path has sudo privileges
	// for the given client token
	SudoPrivilege(ctx context.Context, in *SudoPrivilegeArgs, opts ...grpc.CallOption) (*SudoPrivilegeReply, error)
	// Tainted, returns true if the mount is tainted. A mount is tainted if it is in the
	// process of being unmounted. This should only be used in special
	// circumstances; a primary use-case is as a guard in revocation functions.
	// If revocation of a backend's leases fails it can keep the unmounting
	// process from being successful. If the reason for this failure is not
	// relevant when the mount is tainted (for instance, saving a CRL to disk
	// when the stored CRL will be removed during the unmounting process
	// anyways), we can ignore the errors to allow unmounting to complete.
	Tainted(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaintedReply, error)
	// CachingDisabled returns true if caching is disabled. If true, no caches
	// should be used, despite known slowdowns.
	CachingDisabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CachingDisabledReply, error)
	// ReplicationState indicates the state of cluster replication
	ReplicationState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ReplicationStateReply, error)
	// ResponseWrapData wraps the given data in a cubbyhole and returns the
	// token used to unwrap.
	ResponseWrapData(ctx context.Context, in *ResponseWrapDataArgs, opts ...grpc.CallOption) (*ResponseWrapDataReply, error)
	// MlockEnabled returns the configuration setting for enabling mlock on
	// plugins.
	MlockEnabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MlockEnabledReply, error)
	// LocalMount, when run from a system view attached to a request, indicates
	// whether the request is affecting a local mount or not
	LocalMount(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LocalMountReply, error)
	// EntityInfo returns the basic entity information for the given entity id
	EntityInfo(ctx context.Context, in *EntityInfoArgs, opts ...grpc.CallOption) (*EntityInfoReply, error)
}

type systemViewClient struct {
	cc *grpc.ClientConn
}

func NewSystemViewClient(cc *grpc.ClientConn) SystemViewClient {
	return &systemViewClient{cc}
}

func (c *systemViewClient) DefaultLeaseTTL(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TTLReply, error) {
	out := new(TTLReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/DefaultLeaseTTL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) MaxLeaseTTL(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TTLReply, error) {
	out := new(TTLReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/MaxLeaseTTL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) SudoPrivilege(ctx context.Context, in *SudoPrivilegeArgs, opts ...grpc.CallOption) (*SudoPrivilegeReply, error) {
	out := new(SudoPrivilegeReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/SudoPrivilege", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) Tainted(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaintedReply, error) {
	out := new(TaintedReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/Tainted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) CachingDisabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CachingDisabledReply, error) {
	out := new(CachingDisabledReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/CachingDisabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) ReplicationState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ReplicationStateReply, error) {
	out := new(ReplicationStateReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/ReplicationState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) ResponseWrapData(ctx context.Context, in *ResponseWrapDataArgs, opts ...grpc.CallOption) (*ResponseWrapDataReply, error) {
	out := new(ResponseWrapDataReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/ResponseWrapData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) MlockEnabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MlockEnabledReply, error) {
	out := new(MlockEnabledReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/MlockEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) LocalMount(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LocalMountReply, error) {
	out := new(LocalMountReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/LocalMount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemViewClient) EntityInfo(ctx context.Context, in *EntityInfoArgs, opts ...grpc.CallOption) (*EntityInfoReply, error) {
	out := new(EntityInfoReply)
	err := c.cc.Invoke(ctx, "/pb.SystemView/EntityInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemViewServer is the server API for SystemView service.
type SystemViewServer interface {
	// DefaultLeaseTTL returns the default lease TTL set in Vault configuration
	DefaultLeaseTTL(context.Context, *Empty) (*TTLReply, error)
	// MaxLeaseTTL returns the max lease TTL set in Vault configuration; backend
	// authors should take care not to issue credentials that last longer than
	// this value, as Vault will revoke them
	MaxLeaseTTL(context.Context, *Empty) (*TTLReply, error)
	// SudoPrivilege returns true if given path has sudo privileges
	// for the given client token
	SudoPrivilege(context.Context, *SudoPrivilegeArgs) (*SudoPrivilegeReply, error)
	// Tainted, returns true if the mount is tainted. A mount is tainted if it is in the
	// process of being unmounted. This should only be used in special
	// circumstances; a primary use-case is as a guard in revocation functions.
	// If revocation of a backend's leases fails it can keep the unmounting
	// process from being successful. If the reason for this failure is not
	// relevant when the mount is tainted (for instance, saving a CRL to disk
	// when the stored CRL will be removed during the unmounting process
	// anyways), we can ignore the errors to allow unmounting to complete.
	Tainted(context.Context, *Empty) (*TaintedReply, error)
	// CachingDisabled returns true if caching is disabled. If true, no caches
	// should be used, despite known slowdowns.
	CachingDisabled(context.Context, *Empty) (*CachingDisabledReply, error)
	// ReplicationState indicates the state of cluster replication
	ReplicationState(context.Context, *Empty) (*ReplicationStateReply, error)
	// ResponseWrapData wraps the given data in a cubbyhole and returns the
	// token used to unwrap.
	ResponseWrapData(context.Context, *ResponseWrapDataArgs) (*ResponseWrapDataReply, error)
	// MlockEnabled returns the configuration setting for enabling mlock on
	// plugins.
	MlockEnabled(context.Context, *Empty) (*MlockEnabledReply, error)
	// LocalMount, when run from a system view attached to a request, indicates
	// whether the request is affecting a local mount or not
	LocalMount(context.Context, *Empty) (*LocalMountReply, error)
	// EntityInfo returns the basic entity information for the given entity id
	EntityInfo(context.Context, *EntityInfoArgs) (*EntityInfoReply, error)
}

func RegisterSystemViewServer(s *grpc.Server, srv SystemViewServer) {
	s.RegisterService(&_SystemView_serviceDesc, srv)
}

func _SystemView_DefaultLeaseTTL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).DefaultLeaseTTL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/DefaultLeaseTTL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).DefaultLeaseTTL(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_MaxLeaseTTL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).MaxLeaseTTL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/MaxLeaseTTL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).MaxLeaseTTL(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_SudoPrivilege_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SudoPrivilegeArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).SudoPrivilege(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/SudoPrivilege",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).SudoPrivilege(ctx, req.(*SudoPrivilegeArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_Tainted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).Tainted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/Tainted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).Tainted(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_CachingDisabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).CachingDisabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/CachingDisabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).CachingDisabled(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_ReplicationState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).ReplicationState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/ReplicationState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).ReplicationState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_ResponseWrapData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResponseWrapDataArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).ResponseWrapData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/ResponseWrapData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).ResponseWrapData(ctx, req.(*ResponseWrapDataArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_MlockEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).MlockEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/MlockEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).MlockEnabled(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_LocalMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).LocalMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/LocalMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).LocalMount(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemView_EntityInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntityInfoArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemViewServer).EntityInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemView/EntityInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemViewServer).EntityInfo(ctx, req.(*EntityInfoArgs))
	}
	return interceptor(ctx, in, info, handler)
}

var _SystemView_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SystemView",
	HandlerType: (*SystemViewServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DefaultLeaseTTL",
			Handler:    _SystemView_DefaultLeaseTTL_Handler,
		},
		{
			MethodName: "MaxLeaseTTL",
			Handler:    _SystemView_MaxLeaseTTL_Handler,
		},
		{
			MethodName: "SudoPrivilege",
			Handler:    _SystemView_SudoPrivilege_Handler,
		},
		{
			MethodName: "Tainted",
			Handler:    _SystemView_Tainted_Handler,
		},
		{
			MethodName: "CachingDisabled",
			Handler:    _SystemView_CachingDisabled_Handler,
		},
		{
			MethodName: "ReplicationState",
			Handler:    _SystemView_ReplicationState_Handler,
		},
		{
			MethodName: "ResponseWrapData",
			Handler:    _SystemView_ResponseWrapData_Handler,
		},
		{
			MethodName: "MlockEnabled",
			Handler:    _SystemView_MlockEnabled_Handler,
		},
		{
			MethodName: "LocalMount",
			Handler:    _SystemView_LocalMount_Handler,
		},
		{
			MethodName: "EntityInfo",
			Handler:    _SystemView_EntityInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "logical/plugin/pb/backend.proto",
}

func init() {
	proto.RegisterFile("logical/plugin/pb/backend.proto", fileDescriptor_backend_1a730c5561cd075d)
}

var fileDescriptor_backend_1a730c5561cd075d = []byte{
	// 2202 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xdd, 0x72, 0x1b, 0x49,
	0x15, 0x2e, 0xfd, 0x8f, 0x8e, 0x24, 0xcb, 0xee, 0x38, 0x61, 0xa2, 0x64, 0xb1, 0x98, 0x54, 0xb2,
	0xda, 0x14, 0x51, 0x12, 0xc1, 0x42, 0x16, 0x6a, 0x97, 0x0a, 0x8e, 0x37, 0x6b, 0x36, 0xde, 0x35,
	0x63, 0x87, 0x85, 0x82, 0x2a, 0x6d, 0x7b, 0xa6, 0x2d, 0x4f, 0x79, 0x34, 0x33, 0xf4, 0xf4, 0xc4,
	0xd1, 0x15, 0x0f, 0x41, 0x15, 0x17, 0xbc, 0x04, 0xb7, 0xdc, 0x71, 0x4b, 0x15, 0xd7, 0xbc, 0x06,
	0xcf, 0x40, 0xf5, 0xe9, 0x9e, 0x51, 0x8f, 0x24, 0x93, 0x50, 0x05, 0x77, 0x73, 0x7e, 0xba, 0x4f,
	0xf7, 0xe9, 0x73, 0xbe, 0xaf, 0x7b, 0x60, 0x2f, 0x8c, 0x67, 0x81, 0x47, 0xc3, 0xc7, 0x49, 0x98,
	0xcd, 0x82, 0xe8, 0x71, 0x72, 0xf6, 0xf8, 0x8c, 0x7a, 0x97, 0x2c, 0xf2, 0xc7, 0x09, 0x8f, 0x45,
	0x4c, 0xaa, 0xc9, 0xd9, 0x60, 0x6f, 0x16, 0xc7, 0xb3, 0x90, 0x3d, 0x46, 0xcd, 0x59, 0x76, 0xfe,
	0x58, 0x04, 0x73, 0x96, 0x0a, 0x3a, 0x4f, 0x94, 0x93, 0xd3, 0x82, 0xc6, 0xc1, 0x3c, 0x11, 0x0b,
	0x67, 0x08, 0xcd, 0x2f, 0x18, 0xf5, 0x19, 0x27, 0xb7, 0xa0, 0x79, 0x81, 0x5f, 0x76, 0x65, 0x58,
	0x1b, 0xb5, 0x5d, 0x2d, 0x39, 0xbf, 0x05, 0x38, 0x96, 0x63, 0x0e, 0x38, 0x8f, 0x39, 0xb9, 0x0d,
	0x16, 0xe3, 0x7c, 0x2a, 0x16, 0x09, 0xb3, 0x2b, 0xc3, 0xca, 0xa8, 0xe7, 0xb6, 0x18, 0xe7, 0xa7,
	0x8b, 0x84, 0x91, 0xef, 0x80, 0xfc, 0x9c, 0xce, 0xd3, 0x99, 0x5d, 0x1d, 0x56, 0xe4, 0x0c, 0x8c,
	0xf3, 0xa3, 0x74, 0x96, 0x8f, 0xf1, 0x62, 0x9f, 0xd9, 0xb5, 0x61, 0x65, 0x54, 0xc3, 0x31, 0xfb,
	0xb1, 0xcf, 0x9c, 0x3f, 0x55, 0xa0, 0x71, 0x4c, 0xc5, 0x45, 0x4a, 0x08, 0xd4, 0x79, 0x1c, 0x0b,
	0x1d, 0x1c, 0xbf, 0xc9, 0x08, 0xfa, 0x59, 0x44, 0x33, 0x71, 0xc1, 0x22, 0x11, 0x78, 0x54, 0x30,
	0xdf, 0xae, 0xa2, 0x79, 0x55, 0x4d, 0xee, 0x41, 0x2f, 0x8c, 0x3d, 0x1a, 0x4e, 0x53, 0x11, 0x73,
	0x3a, 0x93, 0x71, 0xa4, 0x5f, 0x17, 0x95, 0x27, 0x4a, 0x47, 0x1e, 0xc2, 0x4e, 0xca, 0x68, 0x38,
	0xbd, 0xe2, 0x34, 0x29, 0x1c, 0xeb, 0x6a, 0x42, 0x69, 0xf8, 0x86, 0xd3, 0x44, 0xfb, 0x3a, 0x7f,
	0x6b, 0x42, 0xcb, 0x65, 0xbf, 0xcf, 0x58, 0x2a, 0xc8, 0x16, 0x54, 0x03, 0x1f, 0x77, 0xdb, 0x76,
	0xab, 0x81, 0x4f, 0xc6, 0x40, 0x5c, 0x96, 0x84, 0x32, 0x74, 0x10, 0x47, 0xfb, 0x61, 0x96, 0x0a,
	0xc6, 0xf5, 0x9e, 0x37, 0x58, 0xc8, 0x5d, 0x68, 0xc7, 0x09, 0xe3, 0xa8, 0xc3, 0x04, 0xb4, 0xdd,
	0xa5, 0x42, 0x6e, 0x3c, 0xa1, 0xe2, 0xc2, 0xae, 0xa3, 0x01, 0xbf, 0xa5, 0xce, 0xa7, 0x82, 0xda,
	0x0d, 0xa5, 0x93, 0xdf, 0xc4, 0x81, 0x66, 0xca, 0x3c, 0xce, 0x84, 0xdd, 0x1c, 0x56, 0x46, 0x9d,
	0x09, 0x8c, 0x93, 0xb3, 0xf1, 0x09, 0x6a, 0x5c, 0x6d, 0x21, 0x77, 0xa1, 0x2e, 0xf3, 0x62, 0xb7,
	0xd0, 0xc3, 0x92, 0x1e, 0xcf, 0x33, 0x71, 0xe1, 0xa2, 0x96, 0x4c, 0xa0, 0xa5, 0xce, 0x34, 0xb5,
	0xad, 0x61, 0x6d, 0xd4, 0x99, 0xd8, 0xd2, 0x41, 0xef, 0x72, 0xac, 0xca, 0x20, 0x3d, 0x88, 0x04,
	0x5f, 0xb8, 0xb9, 0x23, 0xf9, 0x1e, 0x74, 0xbd, 0x30, 0x60, 0x91, 0x98, 0x8a, 0xf8, 0x92, 0x45,
	0x76, 0x1b, 0x57, 0xd4, 0x51, 0xba, 0x53, 0xa9, 0x22, 0x13, 0xb8, 0x69, 0xba, 0x4c, 0xa9, 0xe7,
	0xb1, 0x34, 0x8d, 0xb9, 0x0d, 0xe8, 0x7b, 0xc3, 0xf0, 0x7d, 0xae, 0x4d, 0x72, 0x5a, 0x3f, 0x48,
	0x93, 0x90, 0x2e, 0xa6, 0x11, 0x9d, 0x33, 0xbb, 0xa3, 0xa6, 0xd5, 0xba, 0xaf, 0xe8, 0x9c, 0x91,
	0x3d, 0xe8, 0xcc, 0xe3, 0x2c, 0x12, 0xd3, 0x24, 0x0e, 0x22, 0x61, 0x77, 0xd1, 0x03, 0x50, 0x75,
	0x2c, 0x35, 0xe4, 0x03, 0x50, 0x92, 0x2a, 0xc6, 0x9e, 0xca, 0x2b, 0x6a, 0xb0, 0x1c, 0xef, 0xc3,
	0x96, 0x32, 0x17, 0xeb, 0xd9, 0x42, 0x97, 0x1e, 0x6a, 0x8b, 0x95, 0x3c, 0x81, 0x36, 0xd6, 0x43,
	0x10, 0x9d, 0xc7, 0x76, 0x1f, 0xf3, 0x76, 0xc3, 0x48, 0x8b, 0xac, 0x89, 0xc3, 0xe8, 0x3c, 0x76,
	0xad, 0x2b, 0xfd, 0x45, 0x3e, 0x85, 0x3b, 0xa5, 0xfd, 0x72, 0x36, 0xa7, 0x41, 0x14, 0x44, 0xb3,
	0x69, 0x96, 0xb2, 0xd4, 0xde, 0xc6, 0x0a, 0xb7, 0x8d, 0x5d, 0xbb, 0xb9, 0xc3, 0xeb, 0x94, 0xa5,
	0xe4, 0x0e, 0xb4, 0x65, 0xdd, 0x8a, 0xc5, 0x34, 0xf0, 0xed, 0x1d, 0x5c, 0x92, 0xa5, 0x14, 0x87,
	0x3e, 0xf9, 0x10, 0xfa, 0x49, 0x1c, 0x06, 0xde, 0x62, 0x1a, 0xbf, 0x61, 0x9c, 0x07, 0x3e, 0xb3,
	0xc9, 0xb0, 0x32, 0xb2, 0xdc, 0x2d, 0xa5, 0xfe, 0x5a, 0x6b, 0x37, 0xb5, 0xc6, 0x0d, 0x74, 0x5c,
	0x6b, 0x8d, 0x31, 0x80, 0x17, 0x47, 0x11, 0xf3, 0xb0, 0xfc, 0x76, 0x71, 0x87, 0x5b, 0x72, 0x87,
	0xfb, 0x85, 0xd6, 0x35, 0x3c, 0x06, 0x9f, 0x43, 0xd7, 0x2c, 0x05, 0xb2, 0x0d, 0xb5, 0x4b, 0xb6,
	0xd0, 0xe5, 0x2f, 0x3f, 0xc9, 0x10, 0x1a, 0x6f, 0x68, 0x98, 0x31, 0x2c, 0x79, 0x5d, 0x88, 0x6a,
	0x88, 0xab, 0x0c, 0x3f, 0xa9, 0x3e, 0xab, 0x38, 0xbf, 0x84, 0xe6, 0x01, 0x6e, 0x6b, 0xad, 0x7f,
	0x08, 0xd4, 0xf1, 0xd0, 0x55, 0xc7, 0xe0, 0x37, 0xb9, 0x07, 0x2d, 0x1a, 0x06, 0x54, 0x26, 0xb0,
	0x86, 0xb5, 0xd9, 0xc6, 0xe2, 0x95, 0x2a, 0x37, 0xb7, 0x38, 0x14, 0x1a, 0xa8, 0x59, 0x39, 0xfa,
	0xca, 0xbb, 0x8f, 0xbe, 0xba, 0xe9, 0xe8, 0xf3, 0x75, 0xd4, 0x96, 0xeb, 0x70, 0xfe, 0x58, 0x87,
	0xba, 0x6c, 0x19, 0xf2, 0x31, 0xf4, 0x42, 0x46, 0x53, 0x36, 0x8d, 0x13, 0x99, 0x96, 0x14, 0xa3,
	0x74, 0x26, 0xdb, 0x72, 0x59, 0xaf, 0xa4, 0xe1, 0x6b, 0xa5, 0x77, 0xbb, 0xa1, 0x21, 0x49, 0x20,
	0x0a, 0x22, 0xc1, 0x78, 0x44, 0xc3, 0x29, 0xb6, 0xb0, 0x8a, 0xdc, 0xcd, 0x95, 0x2f, 0x64, 0x2b,
	0xaf, 0x56, 0x7f, 0x6d, 0xbd, 0xfa, 0x07, 0x60, 0xe1, 0x89, 0x07, 0x2c, 0xd5, 0x10, 0x55, 0xc8,
	0x64, 0x02, 0xd6, 0x9c, 0x09, 0xaa, 0x11, 0x42, 0x26, 0xeb, 0x56, 0xde, 0xe9, 0xe3, 0x23, 0x6d,
	0x50, 0x6d, 0x5c, 0xf8, 0xad, 0xf5, 0x71, 0x73, 0xbd, 0x8f, 0x07, 0x60, 0x15, 0xf9, 0x6a, 0xa9,
	0xba, 0xcc, 0x65, 0x49, 0x0e, 0x09, 0xe3, 0x41, 0xec, 0xdb, 0x16, 0x96, 0xb7, 0x96, 0x24, 0xb4,
	0x47, 0xd9, 0x5c, 0x15, 0x7e, 0x5b, 0x41, 0x7b, 0x94, 0xcd, 0xd7, 0xeb, 0x1c, 0x56, 0xea, 0x7c,
	0x0f, 0x1a, 0x78, 0xa8, 0xd8, 0xf8, 0xa5, 0xc3, 0x56, 0x7a, 0x32, 0x86, 0xde, 0x8c, 0xc7, 0x59,
	0x32, 0xcd, 0xab, 0xa2, 0xbb, 0x5a, 0x15, 0x5d, 0xb4, 0x3f, 0x57, 0x66, 0x89, 0x16, 0x67, 0x71,
	0x16, 0xf9, 0x53, 0x2f, 0xf0, 0x79, 0x6a, 0xf7, 0x30, 0x65, 0x80, 0xaa, 0x7d, 0xa9, 0x19, 0xfc,
	0x14, 0x7a, 0xa5, 0xdc, 0x6c, 0xa8, 0xeb, 0x5d, 0xb3, 0xae, 0xdb, 0x66, 0x2d, 0xff, 0xa5, 0x02,
	0x5d, 0xf3, 0xd0, 0xe5, 0xe0, 0xd3, 0xd3, 0x57, 0x38, 0xb8, 0xe6, 0xca, 0x4f, 0x09, 0xf2, 0x9c,
	0x45, 0xec, 0x8a, 0x9e, 0x85, 0x6a, 0x02, 0xcb, 0x5d, 0x2a, 0xa4, 0x35, 0x88, 0x3c, 0xce, 0xe6,
	0x2c, 0x12, 0x9a, 0x03, 0x97, 0x0a, 0xf2, 0x09, 0x40, 0x90, 0xa6, 0x19, 0x9b, 0x4a, 0x9a, 0x46,
	0x22, 0xe8, 0x4c, 0x06, 0x63, 0xc5, 0xe1, 0xe3, 0x9c, 0xc3, 0xc7, 0xa7, 0x39, 0x87, 0xbb, 0x6d,
	0xf4, 0x96, 0xb2, 0x3c, 0x98, 0x23, 0xfa, 0x56, 0xae, 0xa5, 0xa1, 0x0e, 0x46, 0x49, 0xce, 0x1f,
	0xa0, 0xa9, 0xb8, 0xe1, 0xff, 0x5a, 0xc8, 0xb7, 0xc1, 0x52, 0x73, 0x07, 0xbe, 0x2e, 0xe2, 0x16,
	0xca, 0x87, 0xbe, 0xf3, 0x8f, 0x0a, 0x58, 0x2e, 0x4b, 0x93, 0x38, 0x4a, 0x99, 0xc1, 0x5d, 0x95,
	0x77, 0x72, 0x57, 0x75, 0x23, 0x77, 0xe5, 0x8c, 0x58, 0x33, 0x18, 0x71, 0x00, 0x16, 0x67, 0x7e,
	0xc0, 0x99, 0x27, 0x34, 0x7b, 0x16, 0xb2, 0xb4, 0x5d, 0x51, 0x2e, 0x41, 0x37, 0xc5, 0x1e, 0x69,
	0xbb, 0x85, 0x4c, 0x9e, 0x9a, 0x90, 0xaf, 0xc8, 0x74, 0x57, 0x41, 0xbe, 0x5a, 0xee, 0x3a, 0xe6,
	0x3b, 0x7f, 0xaf, 0xc2, 0xf6, 0xaa, 0x79, 0x43, 0x11, 0xec, 0x42, 0x43, 0xb5, 0x97, 0xae, 0x20,
	0xb1, 0xd6, 0x58, 0xb5, 0x95, 0xc6, 0xfa, 0x19, 0xf4, 0x3c, 0xce, 0xf0, 0x26, 0xf0, 0xbe, 0xa7,
	0xdf, 0xcd, 0x07, 0x60, 0x01, 0x7c, 0x04, 0xdb, 0x72, 0x95, 0x09, 0xf3, 0x97, 0x68, 0xa7, 0xae,
	0x0d, 0x7d, 0xad, 0x2f, 0xf0, 0xee, 0x21, 0xec, 0xe4, 0xae, 0xcb, 0xce, 0x6c, 0x96, 0x7c, 0x0f,
	0xf2, 0x06, 0xbd, 0x05, 0xcd, 0xf3, 0x98, 0xcf, 0xa9, 0xd0, 0x50, 0xa0, 0x25, 0x59, 0x16, 0xc5,
	0x7a, 0xf1, 0xda, 0x62, 0xa9, 0xb2, 0xc8, 0x95, 0xf2, 0x32, 0x27, 0x5b, 0xbf, 0xb8, 0x68, 0x21,
	0x2c, 0x58, 0xae, 0x95, 0x5f, 0xb0, 0x9c, 0x5f, 0x43, 0x7f, 0x85, 0x5b, 0x37, 0x24, 0x72, 0x19,
	0xbe, 0x5a, 0x0a, 0x5f, 0x9a, 0xb9, 0xb6, 0x32, 0xf3, 0x6f, 0x60, 0xe7, 0x0b, 0x1a, 0xf9, 0x21,
	0xd3, 0xf3, 0x3f, 0xe7, 0x33, 0xa4, 0x0a, 0x7d, 0xd5, 0x9b, 0x6a, 0x12, 0xea, 0xb9, 0x6d, 0xad,
	0x39, 0xf4, 0xc9, 0x7d, 0x68, 0x71, 0xe5, 0xad, 0x0b, 0xaf, 0x63, 0x90, 0xbf, 0x9b, 0xdb, 0x9c,
	0x6f, 0x81, 0x94, 0xa6, 0x96, 0xb7, 0xbc, 0x05, 0x19, 0xc9, 0x02, 0x54, 0x45, 0xa1, 0x0b, 0xbb,
	0x6b, 0xd6, 0x91, 0x5b, 0x58, 0xc9, 0x10, 0x6a, 0x8c, 0x73, 0x1d, 0x02, 0xd9, 0x77, 0x79, 0xa7,
	0x76, 0xa5, 0xc9, 0xf9, 0x21, 0xec, 0x9c, 0x24, 0xcc, 0x0b, 0x68, 0x88, 0xf7, 0x61, 0x15, 0x60,
	0x0f, 0x1a, 0x32, 0xc9, 0x79, 0xcf, 0x22, 0xfa, 0x29, 0xb3, 0xd2, 0x3b, 0xdf, 0x82, 0xad, 0xd6,
	0x75, 0xf0, 0x36, 0x48, 0x05, 0x8b, 0x3c, 0xb6, 0x7f, 0xc1, 0xbc, 0xcb, 0xff, 0xe1, 0xce, 0xdf,
	0xc0, 0xed, 0x4d, 0x11, 0xf2, 0xf5, 0x75, 0x3c, 0x29, 0x4d, 0xcf, 0x25, 0xd0, 0x62, 0x0c, 0xcb,
	0x05, 0x54, 0x7d, 0x2e, 0x35, 0xf2, 0x1c, 0x99, 0x1c, 0x97, 0x6a, 0x48, 0xd4, 0x52, 0x9e, 0x8f,
	0xda, 0xf5, 0xf9, 0xf8, 0x6b, 0x05, 0xda, 0x27, 0x4c, 0x64, 0x09, 0xee, 0xe5, 0x0e, 0xb4, 0xcf,
	0x78, 0x7c, 0xc9, 0xf8, 0x72, 0x2b, 0x96, 0x52, 0x1c, 0xfa, 0xe4, 0x29, 0x34, 0xf7, 0xe3, 0xe8,
	0x3c, 0x98, 0xe1, 0xeb, 0xa0, 0x33, 0xb9, 0xad, 0xd0, 0x45, 0x8f, 0x1d, 0x2b, 0x9b, 0x22, 0x44,
	0xed, 0x48, 0x86, 0xd0, 0xd1, 0xaf, 0xa6, 0xd7, 0xaf, 0x0f, 0x5f, 0xe4, 0x04, 0x6c, 0xa8, 0x06,
	0x9f, 0x40, 0xc7, 0x18, 0xf8, 0x5f, 0xb1, 0xc5, 0x77, 0x01, 0x30, 0xba, 0xca, 0xd1, 0xb6, 0xda,
	0xaa, 0x1e, 0x29, 0xb7, 0xb6, 0x07, 0x6d, 0x79, 0x4d, 0x51, 0x66, 0x02, 0x75, 0xe3, 0x31, 0x85,
	0xdf, 0xce, 0x7d, 0xd8, 0x39, 0x8c, 0xde, 0xd0, 0x30, 0xf0, 0xa9, 0x60, 0x5f, 0xb2, 0x05, 0xa6,
	0x60, 0x6d, 0x05, 0xce, 0x09, 0x74, 0xf5, 0x73, 0xe5, 0xbd, 0xd6, 0xd8, 0xd5, 0x6b, 0xfc, 0xcf,
	0x4d, 0xf4, 0x11, 0xf4, 0xf5, 0xa4, 0xaf, 0x02, 0xdd, 0x42, 0x92, 0xfc, 0x39, 0x3b, 0x0f, 0xde,
	0xea, 0xa9, 0xb5, 0xe4, 0x3c, 0x83, 0x6d, 0xc3, 0xb5, 0xd8, 0xce, 0x25, 0x5b, 0xa4, 0xf9, 0x33,
	0x4e, 0x7e, 0xe7, 0x19, 0xa8, 0x2e, 0x33, 0xe0, 0xc0, 0x96, 0x1e, 0xf9, 0x92, 0x89, 0x6b, 0x76,
	0xf7, 0x65, 0xb1, 0x90, 0x97, 0x4c, 0x4f, 0xfe, 0x00, 0x1a, 0x4c, 0xee, 0xd4, 0xa4, 0x30, 0x33,
	0x03, 0xae, 0x32, 0x6f, 0x08, 0xf8, 0xac, 0x08, 0x78, 0x9c, 0xa9, 0x80, 0xef, 0x39, 0x97, 0x73,
	0xaf, 0x58, 0xc6, 0x71, 0x26, 0xae, 0x3b, 0xd1, 0xfb, 0xb0, 0xa3, 0x9d, 0x5e, 0xb0, 0x90, 0x09,
	0x76, 0xcd, 0x96, 0x1e, 0x00, 0x29, 0xb9, 0x5d, 0x37, 0xdd, 0x5d, 0xb0, 0x4e, 0x4f, 0x5f, 0x15,
	0xd6, 0x32, 0x36, 0x3a, 0x9f, 0xc2, 0xce, 0x49, 0xe6, 0xc7, 0xc7, 0x3c, 0x78, 0x13, 0x84, 0x6c,
	0xa6, 0x82, 0xe5, 0xaf, 0xc8, 0x8a, 0xf1, 0x8a, 0xdc, 0xc8, 0x46, 0xce, 0x08, 0x48, 0x69, 0x78,
	0x71, 0x6e, 0x69, 0xe6, 0xc7, 0xba, 0x85, 0xf1, 0xdb, 0x19, 0x41, 0xf7, 0x94, 0x4a, 0xbe, 0xf7,
	0x95, 0x8f, 0x0d, 0x2d, 0xa1, 0x64, 0xed, 0x96, 0x8b, 0xce, 0x04, 0x76, 0xf7, 0xa9, 0x77, 0x11,
	0x44, 0xb3, 0x17, 0x41, 0x2a, 0x2f, 0x3c, 0x7a, 0xc4, 0x00, 0x2c, 0x5f, 0x2b, 0xf4, 0x90, 0x42,
	0x76, 0x1e, 0xc1, 0x4d, 0xe3, 0xad, 0x7c, 0x22, 0x68, 0x9e, 0x8f, 0x5d, 0x68, 0xa4, 0x52, 0xc2,
	0x11, 0x0d, 0x57, 0x09, 0xce, 0x57, 0xb0, 0x6b, 0x12, 0xb0, 0xbc, 0x7e, 0xe4, 0x1b, 0xc7, 0x8b,
	0x41, 0xc5, 0xb8, 0x18, 0xe8, 0x9c, 0x55, 0x97, 0x7c, 0xb2, 0x0d, 0xb5, 0x5f, 0x7c, 0x73, 0xaa,
	0x8b, 0x5d, 0x7e, 0x3a, 0xbf, 0x93, 0xe1, 0xcb, 0xf3, 0xa9, 0xf0, 0xa5, 0xdb, 0x41, 0xe5, 0x7d,
	0x6e, 0x07, 0x1b, 0xea, 0xed, 0x11, 0xec, 0x1c, 0x85, 0xb1, 0x77, 0x79, 0x10, 0x19, 0xd9, 0xb0,
	0xa1, 0xc5, 0x22, 0x33, 0x19, 0xb9, 0xe8, 0x7c, 0x08, 0xfd, 0x57, 0xb1, 0x47, 0xc3, 0x23, 0xf9,
	0x3e, 0x29, 0xb2, 0x80, 0x3f, 0x2f, 0xb4, 0xab, 0x12, 0x9c, 0x47, 0xb0, 0xa5, 0x29, 0x3a, 0x3a,
	0x8f, 0x73, 0x64, 0x5c, 0x92, 0x79, 0xa5, 0x7c, 0xcd, 0x76, 0x5e, 0x42, 0x7f, 0xe9, 0xae, 0xe6,
	0x75, 0xa0, 0xa9, 0xcc, 0xe6, 0x55, 0x4c, 0x39, 0xb9, 0xda, 0xb2, 0x71, 0x3f, 0xb0, 0x7c, 0x2e,
	0x4a, 0xd8, 0xe7, 0x6c, 0x1e, 0x0b, 0x36, 0xa5, 0xbe, 0x9f, 0x57, 0x2e, 0x28, 0xd5, 0x73, 0xdf,
	0xe7, 0x93, 0x7f, 0x55, 0xa1, 0xf5, 0x73, 0x05, 0xa6, 0xe4, 0x33, 0xe8, 0x95, 0xa8, 0x93, 0xdc,
	0xc4, 0xf7, 0xe2, 0x2a, 0x51, 0x0f, 0x6e, 0xad, 0xa9, 0xd5, 0x82, 0x9f, 0x40, 0xd7, 0x24, 0x46,
	0x82, 0x24, 0x88, 0x3f, 0xaf, 0x06, 0x38, 0xd3, 0x3a, 0x6b, 0x9e, 0xc0, 0xee, 0x26, 0xca, 0x22,
	0x77, 0x97, 0x11, 0xd6, 0xe9, 0x72, 0xf0, 0xc1, 0x75, 0xd6, 0x9c, 0xea, 0x5a, 0xfb, 0x21, 0xa3,
	0x51, 0x96, 0x98, 0x2b, 0x58, 0x7e, 0x92, 0xa7, 0xd0, 0x2b, 0x81, 0xb6, 0xda, 0xe7, 0x1a, 0x8e,
	0x9b, 0x43, 0x1e, 0x40, 0x03, 0x89, 0x82, 0xf4, 0x4a, 0x8c, 0x35, 0xd8, 0x2a, 0x44, 0x15, 0x7b,
	0x08, 0x75, 0x7c, 0xd7, 0x1a, 0x81, 0x71, 0x44, 0xc1, 0x22, 0x93, 0x7f, 0x56, 0xa0, 0x95, 0xff,
	0xe6, 0x7a, 0x0a, 0x75, 0x89, 0xc7, 0xe4, 0x86, 0x01, 0x69, 0x39, 0x96, 0x0f, 0x76, 0x57, 0x94,
	0x2a, 0xc0, 0x18, 0x6a, 0x2f, 0x99, 0x20, 0xc4, 0x30, 0x6a, 0x60, 0x1e, 0xdc, 0x28, 0xeb, 0x0a,
	0xff, 0xe3, 0xac, 0xec, 0xaf, 0x71, 0xb5, 0xe4, 0x5f, 0x20, 0xe6, 0x8f, 0xa1, 0xa9, 0x10, 0x4f,
	0x25, 0x65, 0x0d, 0x2b, 0xd5, 0xe1, 0xaf, 0x63, 0xe3, 0xe4, 0xcf, 0x75, 0x80, 0x93, 0x45, 0x2a,
	0xd8, 0xfc, 0x57, 0x01, 0xbb, 0x22, 0x0f, 0xa1, 0xff, 0x82, 0x9d, 0xd3, 0x2c, 0x14, 0xf8, 0x72,
	0x91, 0x9d, 0x6d, 0xe4, 0x04, 0x2f, 0x5f, 0x05, 0x70, 0x3e, 0x80, 0xce, 0x11, 0x7d, 0xfb, 0x6e,
	0xbf, 0xcf, 0xa0, 0x57, 0xc2, 0x43, 0xbd, 0xc4, 0x55, 0x84, 0xd5, 0x4b, 0x5c, 0x47, 0xce, 0x07,
	0xd0, 0xd2, 0x28, 0x69, 0xc6, 0x40, 0x3e, 0x29, 0xa1, 0xe7, 0x8f, 0xa0, 0xbf, 0x82, 0x91, 0xa6,
	0x3f, 0xfe, 0x8a, 0xdb, 0x88, 0xa1, 0xcf, 0xe4, 0xcb, 0xa3, 0x8c, 0x93, 0xe6, 0xc0, 0xdb, 0x0a,
	0x9b, 0x36, 0x01, 0xe9, 0xcb, 0xf2, 0x9b, 0x05, 0x5f, 0x6c, 0xf6, 0x2a, 0x94, 0xe5, 0x40, 0x9a,
	0x4f, 0xb4, 0x09, 0x12, 0x9f, 0x40, 0xd7, 0x44, 0xb3, 0xb5, 0x16, 0x5c, 0x87, 0xba, 0xef, 0x03,
	0x2c, 0x01, 0xcd, 0xf4, 0xc7, 0xf2, 0x58, 0xc5, 0xba, 0x8f, 0x01, 0x96, 0x30, 0xa5, 0xaa, 0xaa,
	0x8c, 0x72, 0x6a, 0xd8, 0x0a, 0x94, 0x9d, 0x35, 0xf1, 0x71, 0xf4, 0x83, 0x7f, 0x07, 0x00, 0x00,
	0xff, 0xff, 0xe9, 0x97, 0x76, 0x0e, 0x13, 0x17, 0x00, 0x00,
}
