package aliasmetadata

import (
	"reflect"
	"sort"
	"testing"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
)

var testFields = &Fields{
	FieldName:      "some-field-name",
	Default:        []string{"fizz", "buzz"},
	AvailableToAdd: []string{"foo", "bar"},
}

func TestFieldSchema(t *testing.T) {
	schema := FieldSchema(testFields)
	if schema.Type != framework.TypeCommaStringSlice {
		t.Fatal("expected TypeCommaStringSlice")
	}
	if schema.Description != `The metadata to include on the aliases generated by this plugin. When set to 'default', includes: fizz, buzz. These fields are available to add: foo, bar. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no alias metadata will be included. Add fields by sending, 'default,field1,field2'. We advise only including fields that change rarely because each change triggers a storage write.` {
		t.Fatal("received unexpected description: " + schema.Description)
	}
	if schema.DisplayAttrs == nil {
		t.Fatal("expected display attributes")
	}
	if schema.DisplayAttrs.Name != testFields.FieldName {
		t.Fatalf("expected name of %s", testFields.FieldName)
	}
	if schema.DisplayAttrs.Value != "default,field1,field2" {
		t.Fatal("expected default,field1,field2")
	}
	if !reflect.DeepEqual(schema.Default, []string{"default"}) {
		t.Fatal("expected default")
	}
}

func TestGetAliasMetadata(t *testing.T) {
	h := NewHandler(testFields)
	expected := []string{"fizz", "buzz"}
	sort.Strings(expected)
	actual := h.AliasMetadata()
	sort.Strings(actual)
	if !reflect.DeepEqual(expected, actual) {
		t.Fatalf("expected %s but received %s", expected, actual)
	}
}

func TestParseAliasMetadata(t *testing.T) {
	h := NewHandler(testFields)
	data := &framework.FieldData{
		Raw: map[string]interface{}{
			testFields.FieldName: []string{"default"},
		},
		Schema: map[string]*framework.FieldSchema{
			testFields.FieldName: FieldSchema(testFields),
		},
	}
	if err := h.ParseAliasMetadata(data); err != nil {
		t.Fatal(err)
	}
	expected := []string{"fizz", "buzz"}
	sort.Strings(expected)
	actual := h.AliasMetadata()
	sort.Strings(actual)
	if !reflect.DeepEqual(expected, actual) {
		t.Fatalf("expected %s but received %s", expected, actual)
	}
}

func TestPopulateDesiredAliasMetadata(t *testing.T) {
	h := NewHandler(testFields)
	data := &framework.FieldData{
		Raw: map[string]interface{}{
			testFields.FieldName: []string{"foo"},
		},
		Schema: map[string]*framework.FieldSchema{
			testFields.FieldName: FieldSchema(testFields),
		},
	}
	if err := h.ParseAliasMetadata(data); err != nil {
		t.Fatal(err)
	}
	auth := &logical.Auth{
		Alias: &logical.Alias{
			Name: "foo",
		},
	}
	if err := h.PopulateDesiredAliasMetadata(auth, map[string]string{
		"fizz": "fizzval",
		"buzz": "buzzval",
		"foo":  "fooval",
	}); err != nil {
		t.Fatal(err)
	}
	if len(auth.Alias.Metadata) != 1 {
		t.Fatal("expected only 1 configured field to be populated")
	}
	if auth.Alias.Metadata["foo"] != "fooval" {
		t.Fatal("expected foova;")
	}
}
