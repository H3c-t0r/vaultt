package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/types"
	"io"
	"log"
	"os"
	"strings"

	"github.com/go-git/go-git/v5"
	"golang.org/x/tools/go/packages"
)

func isEnterprise() bool {
	repo, err := git.PlainOpenWithOptions(".", &git.PlainOpenOptions{
		DetectDotGit: true,
	})
	if err != nil {
		log.Fatal(err)
	}
	wt, err := repo.Worktree()
	if err != nil {
		log.Fatal(err)
	}

	st, err := wt.Filesystem.Stat("enthelpers")
	onOss := errors.Is(err, os.ErrNotExist)
	onEnt := st != nil

	switch {
	case onOss && !onEnt:
	case !onOss && onEnt:
	default:
		log.Fatal(err)
	}
	return onEnt
}

func main() {
	if !isEnterprise() {
		return
	}
	baseFilename := strings.TrimSuffix(os.Getenv("GOFILE"), "_oss.go")
	if err := writeStubIfNeeded(baseFilename); err != nil {
		log.Fatal(err)
	}
}

func readLines(r io.Reader) ([]string, error) {
	scanner := bufio.NewScanner(r)
	scanner.Split(bufio.ScanLines)

	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return lines, nil
}

func writeStubIfNeeded(baseFilename string) (err error) {
	warning := "// Code generated by tools/stubmaker; DO NOT EDIT."

	var output *os.File
	inputFile := fmt.Sprintf("%s_oss.go", baseFilename)
	b, err := os.ReadFile(inputFile)
	if err != nil {
		return err
	}

	inputLines, err := readLines(bytes.NewBuffer(b))
	var funcs []string
	var outputLines []string
	for _, line := range inputLines {
		switch line {
		case "//go:build !enterprise":
			outputLines = append(outputLines, warning, "")
			line = "//go:build enterprise"
		case "//go:generate go run github.com/hashicorp/vault/tools/stubmaker":
			continue
		}
		outputLines = append(outputLines, line)

		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "func ") {
			i := strings.Index(trimmed, "(")
			if i != -1 {
				funcs = append(funcs, trimmed[5:i])
			}
		}
	}

	target := fmt.Sprintf("%s_ent.go", baseFilename)
	os.Remove(target)

	pkg, err := parsePackage(".", []string{"enterprise"})
	if err != nil {
		log.Fatal(err)
	}

	var found []string
	for name, val := range pkg.TypesInfo.Defs {
		if val == nil {
			continue
		}
		_, ok := val.Type().(*types.Signature)
		if !ok {
			continue
		}
		for _, f := range funcs {
			if name.Name == f {
				found = append(found, f)
			}
		}
	}
	switch {
	case len(found) == len(funcs):
		return
	case len(found) != 0:
		log.Fatalf("funcs partially defined: need=%v, found=%v", funcs, found)
	}

	output, err = os.Create(target + ".tmp")
	if err != nil {
		return err
	}
	// If we don't end up writing to the file, delete it.
	defer func() {
		if err != nil {
			os.Remove(target + ".tmp")
		} else {
			os.Rename(target+".tmp", target)
		}
	}()

	_, err = io.WriteString(output, strings.Join(outputLines, "\n"))
	return err
}

func parsePackage(name string, tags []string) (*packages.Package, error) {
	cfg := &packages.Config{
		Mode:       packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, name)
	if err != nil {
		return nil, err
	}
	if len(pkgs) != 1 {
		return nil, fmt.Errorf("error: %d packages found", len(pkgs))
	}
	return pkgs[0], nil
}
