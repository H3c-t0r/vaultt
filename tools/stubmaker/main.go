package main

import (
	"bufio"
	"errors"
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"

	"github.com/go-git/go-git/v5"
	"golang.org/x/tools/go/packages"
)

func main() {
	baseFilename := strings.TrimSuffix(os.Getenv("GOFILE"), ".go")
	packageName := os.Getenv("GOPACKAGE")
	stub := os.Args[1]
	enterprise, repoString, tags := repoDetails()
	pkg, err := parsePackage(".", tags)
	if err != nil {
		log.Fatal(err)
	}
	target := fmt.Sprintf("%s_%s_stubs.go", baseFilename, repoString)
	appendStub(target, packageName, stub, enterprise, pkg)
}

func repoDetails() (bool, string, []string) {
	repo, err := git.PlainOpenWithOptions(".", &git.PlainOpenOptions{
		DetectDotGit: true,
	})
	if err != nil {
		log.Fatal(err)
	}
	wt, err := repo.Worktree()
	if err != nil {
		log.Fatal(err)
	}

	st, err := wt.Filesystem.Stat("enthelpers")
	onOss := errors.Is(err, os.ErrNotExist)
	onEnt := st != nil

	var repoString string
	var tags []string
	switch {
	case onOss && !onEnt:
		repoString, tags = "oss", nil
	case !onOss && onEnt:
		repoString, tags = "ent", []string{"enterprise"}
	default:
		log.Fatal(err)
	}
	return onEnt, repoString, tags
}

func appendStub(target string, packageName string, stub string, enterprise bool, pkg *packages.Package) (err error) {
	prelude := `// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by tools/stubmaker; DO NOT EDIT.

`

	var added bool

	// Open an existing stub file and read it, or create it if it doesn't exist.
	_, err = os.Stat(target)
	var f *os.File
	var lines []string
	if err == nil {
		f, err = os.OpenFile(target, os.O_RDWR, 0o644)
		if err != nil {
			log.Fatal(err)
		}
		scanner := bufio.NewScanner(f)
		scanner.Split(bufio.ScanLines)

		for scanner.Scan() {
			lines = append(lines, scanner.Text())
		}
	} else {
		if !errors.Is(err, os.ErrNotExist) {
			return err
		}
		f, err = os.Create(target + ".tmp")
		if err != nil {
			return err
		}
		// If we don't end up writing to the file, delete it.
		defer func() {
			if err != nil || !added {
				os.Remove(target + ".tmp")
			} else {
				os.Rename(target+".tmp", target)
			}
		}()

		_, err = f.WriteString(prelude)
		if err != nil {
			return err
		}
	}

	var add []string
	if enterprise {
		parenPos := strings.Index(stub, "(")
		if parenPos == -1 {
			log.Fatal(fmt.Errorf("no paren found"))
		}
		funcName := strings.TrimSpace(stub[:parenPos])
		for name, val := range pkg.TypesInfo.Defs {
			if val == nil {
				continue
			}
			_, ok := val.Type().(*types.Signature)
			if ok && name.Name == funcName {
				// TODO would be nice to check the signature, will be more work
				// since String() renders the sinagture with fully qualified type
				// names (i.e. including the full package).
				//if val.String() != "func "+stub {
				//	log.Fatal(fmt.Errorf("found existing def with different sig: %s", val.String()))
				//}
				return nil
			}
		}
	} else {
		add = append(add, "//go:build !enterprise")
	}
	add = append(add, fmt.Sprintf("package %s", packageName))
	add = append(add, "func "+stub)

	for _, line := range add {
		// TODO should we instead just rely on the same thing we do above,
		// using the types parsed by packages?
		if stringPresent(lines, line) {
			continue
		}
		_, err = f.WriteString(line + "\n\n")
		if err != nil {
			return err
		}
		added = true
	}

	return nil
}

func stringPresent(haystack []string, needle string) bool {
	for _, line := range haystack {
		if strings.Contains(line, needle) {
			return true
		}
	}
	return false
}

func parsePackage(name string, tags []string) (*packages.Package, error) {
	cfg := &packages.Config{
		Mode:       packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, name)
	if err != nil {
		return nil, err
	}
	if len(pkgs) != 1 {
		return nil, fmt.Errorf("error: %d packages found", len(pkgs))
	}
	return pkgs[0], nil
}
