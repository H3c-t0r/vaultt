---
layout: docs
page_title: TITLE
description:: |-
  DESCRIPTION
---

# Best practices for CI/CD pipelines


Orchestrators (Nomad, Terraform, Ansible, etc.) and continuous
integration/continuous delivery (CI/CD) tools (Jenkins, Bamboo, Azure Devops,
GitLab, GitHub Ops, etc.) authenticate to, and request secrets from, Vault
during deployment.

Typical CI/CD workflows can include multiple pipelines each with multiple
deployment targets (e.g., application, service, infrastructure element).

Assume you have a CI/CD workflow that includes two pipelines:

1. Pipeline<sub>1</sub> has two deploy targets: a cloud application and an
   API service.
1. Pipeline<sub>2</sub> has three deploy targets: AWS configuration, PyPi
   publication, and Maven publication.

How would you organize and coordinate the relevant secrets? 

## Option 1: Use a unique identity for each pipeline and deployed target

Every CI/CD pipeline has a unique identity (e.g. app role, token with an entity
alias). When a pipeline runs, it authenticates to Vault **once** and gives
each deployed component a unique identity.

Any component that needs access to secrets can use its provided identity during
bootstrap to authenticate to Vault and retrieve the relevant information.

## Option 2: Use a unique identity for each pipeline

Every CI/CD pipeline has a unique identity (e.g. app role, token with an entity
alias). The pipeline authenticates to Vault **once** and retrieves all the
relevant secrets.

Any component that needs access to secrets will have the relevant information
immediately. 

## Option 3: Use a central CI/CD identity

The overall CI/CD orchestrator has central identity (e.g. app role, token with
an entity alias). The orchestrator starts by authenticating to Vault and
provides each pipeline with any secrets the pipeline needs in addition to any
secrets needed by the components that pipeline deploys.

## ???

From a threat model and security assessment perspective, **Option 1** is the most
secure approach. With unique identities for 
where the pipeline does not have access to any secret, but allows applications,
services or infrastructure to get its own secrets upon bootstrapping, is the
most secure approach. With **_options 1_** and **_2_**, there is a risk that if
someone gets access to your CI/CD workflow **_(option 1)_**, or your pipelines
**_(option 2)_**, they would gain access to every or some of the secrets used by
your apps and services. Using the
[principle of least privilege](/vault/tutorials/recommended-patterns/pattern-centralized-secrets#the-principle-of-least-privilege-polp),
where you only want to give access to secrets where necessary, there should be
little or no gap between your secrets distribution and when it is accessed.
Therefore one should avoid inadvertently giving your orchestrator and CI/CD tool
god-like privileges where it potentially can access every secret for every app,
service or infrastructure you deploy.

If someone goes wrong in **_option 1_** and you revoke access, all pipelines are
affected. If something goes wrong in **_option 2_** and you revoke access to a
pipeline, only that pipeline is affected, and you limit your security risk blast
radius. If something goes wrong in **_option 3_** you can just revoke an app or
service without affecting everything else. Please carefully consider your
security options as you manage security in a dynamic world.

From a Vault client perspective, **_option 1_** is one client, the Master CI/CD
identity; **_option 2_** is one client for the Master CI/CD identity, and one
client for each pipeline; **_option 3_** is one client for the Master CI/CD
identity, one client for each pipeline, and one for each app, service deployed.

## Try it out!
 
[Onboarding Applications to Vault Using Terraform: A Practical Guide](https://www.hashicorp.com/blog/onboarding-applications-to-vault-using-terraform-a-practical-guide)
provides a detailed example of an automated HashiCorp Vault onboarding
system with Terraform that uses secure identity assignment, naming standards,
ACL policy templates, namespaces, pre-created application entities, and
workflows driven by VCS and CI/CD.

